[
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring f(int A, int B) {\n    string result;\n    for (int i = 0; i < A; i++) {\n        result += 'A';\n    }\n    for (int i = 0; i < B; i++) {\n        result += 'B';\n    }\n    return result;\n}\n\nint main() {\n    int A_i, B_i, C_i, D_i;\n    cin >> A_i >> B_i >> C_i >> D_i;\n    string substring = f(A_i, B_i).substr(C_i - 1, D_i - C_i + 1);\n    cout << substring << endl;\n    return 0;\n}",
    "cpp\n// Problem Name: Cheater's Nim\n\n// Input:\nint N;\nint a_1;\nint a_2;\n...\nint a_N;\n\n// Output:\nint cheater_stones;\n\n// Logic:\nint main() {\n    cin >> N;\n    cin >> a_1;\n    cin >> a_2;\n    ...\n    cin >> a_N;\n\n    // Initialize variables\n    int cheater_stones = 0;\n    int remaining_stones = 0;\n\n    // Loop through all piles\n    for (int i = 1; i <= N; i++) {\n        // If there are no stones left in the pile, skip it\n        if (a_i == 0) continue;\n\n        // Compute the maximum number of stones the cheater can take from this pile\n        int max_stones = min(a_i, remaining_stones);\n\n        // Update the number of remaining stones\n        remaining_stones -= max_stones;\n\n        // Update the number of stones the cheater has eaten\n        cheater_stones += max_stones;\n\n        // Print the number of stones the cheater has eaten so far\n        cout << cheater_stones << endl;\n\n        // If there are no more stones left, break\n        if (remaining_stones == 0) break;\n    }\n\n    // If the cheater has eaten all the stones, print -1\n    if (cheater_stones == 0) cout << -1 << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n// A structure to represent a friendship or blockship\nstruct Relationship {\n    int user1;\n    int user2;\n};\n\n// A function to check if there is a friendship or blockship between two users\nbool hasRelationship(int user1, int user2, vector<Relationship> relationships) {\n    for (const auto& relationship : relationships) {\n        if (relationship.user1 == user1 && relationship.user2 == user2) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// A function to find all friend candidates for a given user\nvector<int> findFriendCandidates(int user, vector<Relationship> relationships) {\n    vector<int> friendCandidates;\n    for (int i = 1; i <= N; i++) {\n        if (i != user && !hasRelationship(user, i, relationships)) {\n            friendCandidates.push_back(i);\n        }\n    }\n    return friendCandidates;\n}\n\n// Main function\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n\n    // Initialize vectors for friendships and blockships\n    vector<Relationship> friendships(M);\n    vector<Relationship> blockships(K);\n\n    // Read in friendships and blockships\n    for (int i = 0; i < M; i++) {\n        int A, B;\n        cin >> A >> B;\n        friendships[i] = {A, B};\n    }\n    for (int i = 0; i < K; i++) {\n        int C, D;\n        cin >> C >> D;\n        blockships[i] = {C, D};\n    }\n\n    // Find all friend candidates for each user\n    vector<vector<int>> friendCandidates(N);\n    for (int i = 1; i <= N; i++) {\n        friendCandidates[i] = findFriendCandidates(i, friendships);\n    }\n\n    // Print the number of friend candidates for each user\n    for (int i = 1; i <= N; i++) {\n        cout << friendCandidates[i].size() << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    int min_elements_to_remove = min_elements_to_remove(a);\n    cout << min_elements_to_remove << endl;\n    return 0;\n}\n\nint min_elements_to_remove(vector<int> a) {\n    int n = a.size();\n    int min_elements_to_remove = 0;\n\n    // Find the first duplicate element\n    int first_duplicate = -1;\n    for (int i = 1; i < n; i++) {\n        if (a[i] == a[i - 1]) {\n            first_duplicate = i - 1;\n            break;\n        }\n    }\n\n    // If there are no duplicates, return 0\n    if (first_duplicate == -1) {\n        return 0;\n    }\n\n    // Remove the first duplicate and all subsequent duplicates\n    for (int i = first_duplicate; i < n; i++) {\n        a.erase(a.begin() + i);\n    }\n\n    // Check if the resulting sequence is a good sequence\n    bool is_good_sequence = true;\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n        for (int j = i + 1; j < n; j++) {\n            if (a[j] == a[i]) {\n                count++;\n            }\n        }\n        if (count != a[i]) {\n            is_good_sequence = false;\n            break;\n        }\n    }\n\n    // If the resulting sequence is not a good sequence, add the first duplicate back\n    if (!is_good_sequence) {\n        a.insert(a.begin() + first_duplicate, a[first_duplicate]);\n    }\n\n    // Return the number of elements removed\n    return n - a.size();\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 400;\nconst int MAX_A = 1000000000;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> a(N);\n    for (int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    int min_cost = 0;\n    int cur_cost = 0;\n    for (int i = 0; i < N - 1; i++) {\n        int x = a[i];\n        int y = a[i + 1];\n        int new_size = x + y;\n        cur_cost += new_size;\n        min_cost = min(min_cost, cur_cost);\n    }\n    cout << min_cost << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int M = 20000; // \u73fe\u5728\u624b\u6301\u3061\u306e\u65e5\u672c\u5186\u306e\u984d\n    int r_D = 3; // \u65e5\u672c\u5186\u3068D\u56fd\u306e\u901a\u8ca8\u5358\u4f4d\u3068\u306e\u4e21\u66ff\u30ec\u30fc\u30c8\n    int r_R = 1; // \u65e5\u672c\u5186\u3068R\u56fd\u306e\u901a\u8ca8\u5358\u4f4d\u3068\u306e\u4e21\u66ff\u30ec\u30fc\u30c8\n    int c_D = 20; // D\u56fd\u3067\u306e\u304a\u91d1\u306e\u6d88\u8cbb\u984d\n    int c_R = 100; // R\u56fd\u3067\u306e\u304a\u91d1\u306e\u6d88\u8cbb\u984d\n\n    // D\u56fd\u306e\u304a\u91d1\u3092\u4e21\u66ff\n    int x_D = M / r_D;\n    int y_D = M % r_D;\n    int z_D = x_D * r_D;\n    int w_D = y_D * r_D;\n\n    // R\u56fd\u306e\u304a\u91d1\u3092\u4e21\u66ff\n    int x_R = M / r_R;\n    int y_R = M % r_R;\n    int z_R = x_R * r_R;\n    int w_R = y_R * r_R;\n\n    // \u624b\u5143\u306b\u623b\u3063\u3066\u304f\u308b\u65e5\u672c\u5186\u306e\u6700\u5927\u984d\u3092\u8a08\u7b97\n    int max_yen = z_D + w_D + z_R + w_R;\n\n    // \u51fa\u529b\n    cout << \"Maximum amount of Japanese yen: \" << max_yen << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    string S(N, 'L');\n    for (int i = 0; i < N; i++) {\n        cin >> S[i];\n    }\n    int happy = 0;\n    for (int i = 0; i < K; i++) {\n        int l, r;\n        cin >> l >> r;\n        l--; r--;\n        int rot = (r - l + 1) / 2;\n        int cnt = 0;\n        for (int j = l; j <= r; j++) {\n            if (S[j] == S[j + rot]) {\n                cnt++;\n            }\n        }\n        happy += cnt;\n    }\n    cout << happy << endl;\n    return 0;\n}",
    "// \u5b9d\u304f\u3058\u30c1\u30a7\u30c3\u30ab\u30fc\n\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// \u5b9d\u304f\u3058\u306e\u6570\u5b57\u90e8\u5206\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\u95a2\u6570\nbool check_number(string number, string target) {\n    // \u6570\u5b57\u90e8\u5206\u304c\u4e00\u81f4\u3059\u308b\u5834\u5408\u306ftrue\u3092\u8fd4\u3059\n    return (number.find(target) != string::npos);\n}\n\n// \u5f53\u9078\u756a\u53f7\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\u95a2\u6570\nbool check_winning_number(string number, vector<string> winning_numbers) {\n    // \u5f53\u9078\u756a\u53f7\u304c\u8907\u6570\u3042\u308b\u5834\u5408\u306f\u3001\u305d\u308c\u305e\u308c\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\n    for (int i = 0; i < winning_numbers.size(); i++) {\n        if (check_number(number, winning_numbers[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    // \u5165\u529b\u3092\u53d7\u3051\u53d6\u308b\n    int n, m;\n    cin >> n >> m;\n\n    // \u5f53\u9078\u756a\u53f7\u3092\u53d7\u3051\u53d6\u308b\n    vector<string> winning_numbers(n);\n    for (int i = 0; i < n; i++) {\n        string number;\n        cin >> number;\n        winning_numbers[i] = number;\n    }\n\n    // \u6240\u6301\u3057\u3066\u3044\u308b\u5b9d\u304f\u3058\u306e\u756a\u53f7\u3092\u53d7\u3051\u53d6\u308b\n    vector<string> numbers(m);\n    for (int i = 0; i < m; i++) {\n        string number;\n        cin >> number;\n        numbers[i] = number;\n    }\n\n    // \u5f53\u9078\u91d1\u3092\u8a08\u7b97\u3059\u308b\n    int total_prize = 0;\n    for (int i = 0; i < m; i++) {\n        string number = numbers[i];\n        if (check_winning_number(number, winning_numbers)) {\n            total_prize += atoi(number.c_str());\n        }\n    }\n\n    // \u51fa\u529b\u3059\u308b\n    cout << \"Total Prize: \" << total_prize << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string S;\n    cin >> S;\n\n    // Step 1: Remove all characters except 'A' and 'Z'\n    S.erase(remove_if(S.begin(), S.end(), [](char c) { return c != 'A' && c != 'Z'; }), S.end());\n\n    // Step 2: Repeat 'A' and 'Z' alternately\n    string result;\n    for (int i = 0; i < S.size(); i++) {\n        if (S[i] == 'A') {\n            result.push_back('Z');\n        } else if (S[i] == 'Z') {\n            result.push_back('A');\n        }\n    }\n\n    // Step 3: Check if the resulting string satisfies the condition\n    if (result.size() > 1 && result[0] == 'A' && result[result.size() - 1] == 'Z') {\n        cout << result << endl;\n    } else {\n        cout << \"-1\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n// Node struct to represent a node in the tree\nstruct Node {\n    int index;\n    int parent;\n    bool marked;\n};\n\n// Function to perform a mark operation\nvoid mark(Node* root, int v) {\n    // If the node is not the root node, mark its parent as well\n    if (v != 1) {\n        mark(root, v - 1);\n    }\n    root[v].marked = true;\n}\n\n// Function to perform a query operation\nint query(Node* root, int v) {\n    int nearestAncestor = -1;\n    int distance = -1;\n\n    // Iterate from the current node up to the root node\n    for (int i = v; i > 0; i--) {\n        // If we find a marked ancestor, record its index and distance\n        if (root[i].marked) {\n            nearestAncestor = i;\n            distance = v - i + 1;\n            break;\n        }\n    }\n\n    // If we didn't find a marked ancestor, return -1\n    if (nearestAncestor == -1) {\n        return -1;\n    }\n\n    // Return the index of the nearest marked ancestor and its distance\n    return nearestAncestor;\n}\n\n// Main function to process the input and output the sum of the query operations\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    // Create a vector to store the nodes of the tree\n    vector<Node> tree(N + 1);\n\n    // Initialize the root node\n    tree[1].index = 1;\n    tree[1].parent = 0;\n    tree[1].marked = true;\n\n    // Process the operations\n    for (int i = 0; i < Q; i++) {\n        string operation;\n        cin >> operation;\n\n        // If the operation is a mark operation\n        if (operation == \"M\") {\n            int v;\n            cin >> v;\n            mark(&tree, v);\n        }\n\n        // If the operation is a query operation\n        else if (operation == \"Q\") {\n            int v;\n            cin >> v;\n            int nearestAncestor = query(&tree, v);\n            cout << nearestAncestor << \" \";\n        }\n    }\n\n    // Output the sum of the query operations\n    cout << accumulate(tree.begin() + 1, tree.begin() + N, 0) << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    for (int i = 0; i < N; i++) {\n        int d, h, m, a, ah, am;\n        cin >> d >> h >> m >> a >> ah >> am;\n\n        int tollFee = 0;\n        if (h >= 17 && h <= 19) {\n            tollFee = (d == a) ? 500 : 450;\n        } else {\n            tollFee = (d == a) ? 600 : 550;\n        }\n\n        cout << tollFee << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    set<int> colors;\n    colors.insert(a);\n    colors.insert(b);\n    colors.insert(c);\n    cout << colors.size() << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MAX_N = 15000;\nconst int MAX_K = 30;\n\nint main() {\n    int N, P[MAX_N], K;\n    string S;\n\n    cin >> N >> P[0] >> P[1] >> ... >> P[N-1];\n\n    // Initialize A and B as empty arrays\n    vector<int> A(MAX_N), B(MAX_N);\n\n    // Initialize t as 0\n    int t = 0;\n\n    // Loop for at most 30 operations\n    for (int i = 0; i < MAX_K; i++) {\n        // If S[i] is 0, do nothing\n        if (S[i] == '0') {\n            continue;\n        }\n\n        // If S[i] is 1, add P[i] to the end of A if t = 0, or to the end of B if t = 1\n        if (S[i] == '1') {\n            if (t == 0) {\n                A.push_back(P[i]);\n            } else {\n                B.push_back(P[i]);\n            }\n        }\n\n        // If S[i] is 1, set t to 1 if A is not empty, or set t to 0 if B is not empty\n        if (S[i] == '1') {\n            if (!A.empty()) {\n                t = 1;\n            } else if (!B.empty()) {\n                t = 0;\n            }\n        }\n    }\n\n    // Concatenate A and B in the correct order\n    vector<int> C;\n    if (t == 0) {\n        C = A;\n        C.insert(C.end(), B.begin(), B.end());\n    } else {\n        C = B;\n        C.insert(C.end(), A.begin(), A.end());\n    }\n\n    // Output the number of operations and the final sorted array\n    cout << K << endl;\n    for (int i = 0; i < C.size(); i++) {\n        cout << C[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int maxGCD = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int gcd = __gcd(arr[i], arr[j]);\n            maxGCD = max(maxGCD, gcd);\n        }\n    }\n\n    cout << maxGCD << endl;\n    return 0;\n}\n\nint __gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    }\n    return __gcd(b, a % b);\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<string> S(H);\n    for (int i = 0; i < H; i++) {\n        cin >> S[i];\n    }\n\n    // Initialize bomb squares\n    vector<vector<int>> bombs(H, vector<int>(W, 0));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (S[i][j] == '#') {\n                bombs[i][j] = 1;\n            }\n        }\n    }\n\n    // Count adjacent bombs\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int bombsAdjacent = 0;\n            for (int k = -1; k <= 1; k++) {\n                for (int l = -1; l <= 1; l++) {\n                    int m = i + k;\n                    int n = j + l;\n                    if (m >= 0 && m < H && n >= 0 && n < W && bombs[m][n]) {\n                        bombsAdjacent++;\n                    }\n                }\n            }\n            S[i][j] = bombsAdjacent + '';\n        }\n    }\n\n    // Print the modified strings\n    for (int i = 0; i < H; i++) {\n        cout << S[i] << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <stack>\n#include <cstring>\n\nusing namespace std;\n\nint main() {\n    int m, n, lb, ub;\n    char name[20];\n    stack<int> s;\n\n    cin >> m >> name >> lb >> ub;\n\n    for (int i = 1; i <= m; i++) {\n        if (name[i] == 'a') {\n            s.push(1);\n        } else if (name[i] == 'b') {\n            s.push(2);\n        } else if (name[i] == 'c') {\n            s.push(3);\n        } else if (name[i] == 'd') {\n            s.push(4);\n        } else if (name[i] == 'e') {\n            s.push(5);\n        } else if (name[i] == 'f') {\n            s.push(6);\n        } else if (name[i] == 'g') {\n            s.push(7);\n        } else if (name[i] == 'h') {\n            s.push(8);\n        } else if (name[i] == 'i') {\n            s.push(9);\n        } else if (name[i] == 'j') {\n            s.push(10);\n        } else if (name[i] == 'k') {\n            s.push(11);\n        } else if (name[i] == 'l') {\n            s.push(12);\n        } else if (name[i] == 'm') {\n            s.push(13);\n        } else if (name[i] == 'n') {\n            s.push(14);\n        } else if (name[i] == 'o') {\n            s.push(15);\n        } else if (name[i] == 'p') {\n            s.push(16);\n        } else if (name[i] == 'q') {\n            s.push(17);\n        } else if (name[i] == 'r') {\n            s.push(18);\n        } else if (name[i] == 's') {\n            s.push(19);\n        } else if (name[i] == 't') {\n            s.push(20);\n        } else {\n            s.push(0);\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        int op = s.top();\n        s.pop();\n        int num1 = s.top();\n        s.pop();\n        int num2 = s.top();\n        s.pop();\n        int res = 0;\n        if (op == 1) {\n            res = num1 + num2;\n        } else if (op == 2) {\n            res = num1 - num2;\n        } else if (op == 3) {\n            res = num1 * num2;\n        } else if (op == 4) {\n            res = num1 / num2;\n        }\n        s.push(res);\n    }\n\n    int result = s.top();\n    s.pop();\n    cout << \"Result: \" << result << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int n, x = 0;\n    string s;\n    cin >> n >> s;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'I') {\n            x++;\n        } else if (s[i] == 'D') {\n            x--;\n        }\n    }\n\n    cout << max(x, 0) << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 1e9 + 7;\n\nint main() {\n    int n = 10; // |V|\n    int m = 20; // |E|\n    int root = 0; // r\n\n    vector<vector<int>> graph(n, vector<int>(n, 0));\n\n    // Read in the edges\n    for (int i = 0; i < m; i++) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        graph[s][t] = w;\n    }\n\n    // Compute the minimum cost arborescence\n    vector<int> dist(n, INF);\n    dist[root] = 0;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n    pq.push({0, root});\n\n    while (!pq.empty()) {\n        pair<int, int> top = pq.top();\n        pq.pop();\n\n        int u = top.second;\n\n        // Visit all neighbors of u\n        for (int v = 0; v < n; v++) {\n            if (graph[u][v] != 0) {\n                int new_dist = dist[u] + graph[u][v];\n\n                if (new_dist < dist[v]) {\n                    dist[v] = new_dist;\n                    pq.push({new_dist, v});\n                }\n            }\n        }\n    }\n\n    // Print the sum of the weights of the minimum cost arborescence\n    int sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        sum += dist[i];\n    }\n\n    cout << sum << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n// Definition for a directed edge\nstruct Edge {\n    int from;\n    int to;\n};\n\n// Function to check if there is an Eulerian tour in the graph\nbool hasEulerianTour(vector<Edge> &edges) {\n    // Create a map to keep track of the number of edges between each pair of nodes\n    map<pair<int, int>, int> edgeCount;\n\n    // Iterate through the edges and add them to the map\n    for (const Edge &edge : edges) {\n        edgeCount[make_pair(edge.from, edge.to)]++;\n    }\n\n    // Check if there is an Eulerian tour\n    for (int i = 1; i <= edges.size(); i++) {\n        if (edgeCount[make_pair(i, i + 1)] == 1) {\n            continue;\n        }\n        if (edgeCount[make_pair(i, i - 1)] == 1) {\n            continue;\n        }\n        if (edgeCount[make_pair(i - 1, i)] == 1) {\n            continue;\n        }\n        if (edgeCount[make_pair(i + 1, i)] == 1) {\n            continue;\n        }\n    }\n\n    return true;\n}\n\n// Function to find additional edges to add to the graph to enable an Eulerian tour\nvector<Edge> findAdditionalEdges(vector<Edge> &edges) {\n    // Create a set to keep track of the edges to add\n    set<Edge> additionalEdges;\n\n    // Iterate through the edges and find the missing edges\n    for (const Edge &edge : edges) {\n        // Check if there is a missing edge in the opposite direction\n        if (edge.from != edge.to && edgeCount[make_pair(edge.to, edge.from)] == 0) {\n            additionalEdges.insert({edge.to, edge.from});\n        }\n    }\n\n    // Return the additional edges\n    return vector<Edge>(additionalEdges.begin(), additionalEdges.end());\n}\n\nint main() {\n    // Read the input\n    int n, m;\n    cin >> n >> m;\n\n    // Create a vector to store the edges\n    vector<Edge> edges;\n\n    // Read the edges\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        edges.push_back({a, b});\n    }\n\n    // Check if there is an Eulerian tour in the graph\n    if (hasEulerianTour(edges)) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    // Find additional edges to add to the graph to enable an Eulerian tour\n    vector<Edge> additionalEdges = findAdditionalEdges(edges);\n\n    // Output the additional edges\n    if (additionalEdges.size() > 0) {\n        cout << \"Additional edges: \";\n        for (const Edge &edge : additionalEdges) {\n            cout << edge.from << \" \" << edge.to << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"No additional edges needed\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string s = \"needed\";\n    int n = s.size();\n    int a = -1, b = -1;\n\n    // Check if the string has at least 2 characters and more than half of the letters are the same\n    if (n >= 2 && (n - 1) / 2 > 0) {\n        // Calculate the number of unique letters in the string\n        int uniqueLetters = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] != s[i + 1]) {\n                uniqueLetters++;\n            }\n        }\n\n        // Check if there is an unbalanced substring\n        for (int i = 0; i < n - 1; i++) {\n            if (s[i] == s[i + 1]) {\n                continue;\n            }\n\n            int j = i + 1;\n            while (j < n && s[j] == s[j - 1]) {\n                j++;\n            }\n\n            // Found an unbalanced substring\n            a = i;\n            b = j - 1;\n            break;\n        }\n    }\n\n    // Print the result\n    if (a != -1) {\n        cout << a << \" \" << b << endl;\n    } else {\n        cout << \"-1 -1\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int W, H;\n    cin >> W >> H;\n    vector<vector<int>> d(W);\n    for (int i = 0; i < H; i++) {\n        vector<int> row(W);\n        for (int j = 0; j < W; j++) {\n            int x = j;\n            int y = i;\n            if (x >= 0 && x < W && y >= 0 && y < H) {\n                row[j] = 1;\n            }\n        }\n        d[i] = row;\n    }\n    int N = d.size();\n    int t[N];\n    for (int i = 0; i < N; i++) {\n        t[i] = 0;\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int x = d[i][j];\n            int y = d[j][i];\n            if (x && y) {\n                t[i]++;\n                t[j]++;\n            }\n        }\n    }\n    cout << (t[0] + t[1] + ... + t[N - 1]) % 1000000007 << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<vector<int>> subsets(N);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < K; j++) {\n            cin >> subsets[i][j];\n        }\n    }\n    int maxProduct = 0;\n    for (int i = 0; i < N; i++) {\n        int prod = 1;\n        for (int j = 0; j < K; j++) {\n            prod *= subsets[i][j];\n        }\n        maxProduct = max(maxProduct, prod);\n    }\n    cout << \"Maximum product of selected subsets: \" << maxProduct << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n, sum = 0;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int v;\n        cin >> v;\n        sum += v;\n    }\n    cout << \"The average purchase amount is: \" << (sum / n) << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_H = 100;\nconst int MAX_W = 100;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> grid(H, vector<char>(W, '.'));\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    int S = -1, T = -1;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                S = i * W + j;\n            } else if (grid[i][j] == 'T') {\n                T = i * W + j;\n            }\n        }\n    }\n\n    int removes = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.') {\n                continues;\n            }\n            if (i == S / W || j == S % W) {\n                removes++;\n            }\n        }\n    }\n\n    cout << removes << endl;\n    return 0;\n}",
    "cpp\n// Problem Name: Maximum Sum of Digits\n\n// Description: Find the maximum possible sum of the digits (in base 10) of a positive integer not greater than N.\n\n// Constraints:\n\n// 1 <= N <= 10^16\n\n// N is an integer.\n\n// Input:\n\n// Input is given from Standard Input in the following format:\n\n// N\n\n// Output:\n\n// Print the maximum possible sum of the digits (in base 10) of a positive integer not greater than N.\n\n// Sample Input 1:\n// 100\n\n// Sample Output 1:\n// 18\n\n// Sample Input 2:\n// 9995\n\n// Sample Output 2:\n// 35\n\n// Sample Input 3:\n// 3141592653589793\n\n// Sample Output 3:\n// 137\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int maxSum = 0;\n    while (n != 0) {\n        int digit = n % 10;\n        maxSum = max(maxSum, digit);\n        n /= 10;\n    }\n    cout << \"Maximum sum of digits: \" << maxSum << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 10000000007; // number of people\nconst int A = 2; // capacity of train\nconst int B = 3; // capacity of bus\nconst int C = 5; // capacity of taxi\nconst int D = 7; // capacity of airplane\nconst int E = 11; // capacity of ship\n\nint main() {\n    vector<int> people(N); // people to be transported\n    vector<int> transport(N); // transportation vehicles\n\n    // initialize people and transport vehicles\n    for (int i = 0; i < N; i++) {\n        people[i] = i + 1; // people are numbered from 1 to N\n        transport[i] = 0; // no vehicle assigned yet\n    }\n\n    // assign transportation vehicles\n    for (int i = 0; i < N; i++) {\n        // assign train\n        if (transport[i] == 0 && A > 0) {\n            transport[i] = 1; // assign train to person i\n            A--;\n        }\n        // assign bus\n        else if (transport[i] == 0 && B > 0) {\n            transport[i] = 2; // assign bus to person i\n            B--;\n        }\n        // assign taxi\n        else if (transport[i] == 0 && C > 0) {\n            transport[i] = 3; // assign taxi to person i\n            C--;\n        }\n        // assign airplane\n        else if (transport[i] == 0 && D > 0) {\n            transport[i] = 4; // assign airplane to person i\n            D--;\n        }\n        // assign ship\n        else if (transport[i] == 0 && E > 0) {\n            transport[i] = 5; // assign ship to person i\n            E--;\n        }\n    }\n\n    // calculate minimum time required\n    int minTime = 0;\n    for (int i = 0; i < N; i++) {\n        minTime = max(minTime, people[i] * (transport[i] == 1 ? 1 : transport[i] == 2 ? 2 : transport[i] == 3 ? 3 : transport[i] == 4 ? 4 : 5));\n    }\n\n    // output minimum time\n    cout << minTime << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> grid(H, vector<char>(W));\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    int maxValue = 0;\n    string maxExpression = \"\";\n\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            string expression = \"\";\n            int value = 0;\n\n            for (int k = 1; k <= H + W - 2; k++) {\n                int row = i + k - 1;\n                int col = j + k - 1;\n\n                if (row < 0 || row >= H || col < 0 || col >= W) {\n                    break;\n                }\n\n                char c = grid[row][col];\n\n                if (c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9') {\n                    value = value * 10 + (c - '0');\n                } else if (c == '+' || c == '*') {\n                    expression += c;\n                }\n            }\n\n            if (expression.size() > 0) {\n                value = value * (expression.size() % 2 == 0 ? 1 : -1);\n            }\n\n            if (maxValue < value) {\n                maxValue = value;\n                maxExpression = expression;\n            }\n        }\n    }\n\n    cout << maxValue << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    string S[N];\n    for (int i = 0; i < N; i++) {\n        cin >> S[i];\n    }\n\n    for (int i = 0; i < Q; i++) {\n        int k = cin.nextInt();\n        string p = cin.next();\n        int pos = -1;\n        for (int j = 0; j < N; j++) {\n            if (S[j] == p) {\n                pos = j;\n                break;\n            }\n        }\n        if (pos == -1) {\n            cout << \"Error: \" << p << \" not found.\" << endl;\n            return 1;\n        }\n        cout << pos + 1 << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    vector<int> X(N);\n    for (int i = 0; i < N; i++) {\n        cin >> X[i];\n    }\n\n    // Sort X in ascending order\n    sort(X.begin(), X.end());\n\n    // Calculate the minimum fatigue level increase\n    int min_fatigue = min_fatigue_increase(N, A, B, X);\n\n    // Print the result\n    cout << min_fatigue << endl;\n\n    return 0;\n}\n\nint min_fatigue_increase(int N, int A, int B, vector<int> &X) {\n    int min_fatigue = INT_MAX;\n\n    // Base case: only one town\n    if (N == 1) {\n        return 0;\n    }\n\n    // Walk from town 1 to town N\n    int fatigue_walk = N * A;\n    min_fatigue = min(min_fatigue, fatigue_walk);\n\n    // Teleport from town 1 to town N\n    int fatigue_teleport = B;\n    min_fatigue = min(min_fatigue, fatigue_teleport);\n\n    // Combine walking and teleporting\n    int fatigue_combine = (N - 1) * A + B;\n    min_fatigue = min(min_fatigue, fatigue_combine);\n\n    return min_fatigue;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_L = 2e5 + 1;\nconst int MAX_A = 1e9 + 1;\n\nint main() {\n    int L, A[MAX_L];\n    cin >> L;\n    cin >> A[0];\n    for (int i = 1; i < L; i++) {\n        cin >> A[i];\n    }\n\n    // Initialize Snuke's ear stones\n    vector<int> snuve(L, 0);\n\n    // Calculate the minimum number of operations required\n    int min_ops = 0;\n    for (int i = 0; i < L; i++) {\n        int curr_stone = A[i] - snuve[i];\n        min_ops += abs(curr_stone);\n        snuve[i] += curr_stone;\n    }\n\n    // Print the minimum number of operations required\n    cout << min_ops << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_SIZE = 12;\n\n// \u30de\u30b9\u306e\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u3080\nvoid readData(vector<vector<int>>& data) {\n    int row, col;\n    int num Islands = 0;\n\n    // \u5165\u529b\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u3080\n    for (row = 0; row < MAX_SIZE; row++) {\n        vector<int> rowData(MAX_SIZE, 0);\n        for (col = 0; col < MAX_SIZE; col++) {\n            int value = 0;\n            cin >> value;\n            rowData[col] = value;\n        }\n        data.push_back(rowData);\n    }\n}\n\n// \u5cf6\u306e\u6570\u3092\u8a08\u7b97\u3059\u308b\nint calculateIslands(vector<vector<int>>& data) {\n    int numIslands = 0;\n\n    // \u30de\u30b9\u306e\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u3093\u3067\u3001\u5cf6\u306e\u6570\u3092\u8a08\u7b97\u3059\u308b\n    for (int i = 0; i < data.size(); i++) {\n        vector<int> rowData = data[i];\n        int rowIslands = 0;\n\n        for (int j = 0; j < rowData.size(); j++) {\n            int value = rowData[j];\n\n            // \u9ed2\u3044\u30de\u30b9\u304c\u4e0a\u4e0b\u3001\u3042\u308b\u3044\u306f\u5de6\u53f3\u306b\u63a5\u3057\u3066\u3044\u308b\u5834\u5408\u3001\u5cf6\u306e\u6570\u3092 increment\n            if (value == 1) {\n                rowIslands++;\n            }\n        }\n        numIslands += rowIslands;\n    }\n\n    return numIslands;\n}\n\nint main() {\n    vector<vector<int>> data;\n\n    // \u30de\u30b9\u306e\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u3080\n    readData(data);\n\n    // \u5cf6\u306e\u6570\u3092\u8a08\u7b97\u3059\u308b\n    int numIslands = calculateIslands(data);\n\n    // \u7d50\u679c\u3092\u51fa\u529b\u3059\u308b\n    cout << \"\u5cf6\u306e\u6570: \" << numIslands << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Define a struct to represent the map\nstruct Map {\n    int height;\n    int width;\n    char terrain[20][20];\n};\n\n// Define a function to parse the instructions\nvoid parseInstructions(string instructions) {\n    // TO DO: Implement this function\n}\n\n// Define a function to update the map\nvoid updateMap(Map &map, string instruction) {\n    // TO DO: Implement this function\n}\n\nint main() {\n    // Read in the initial map and instructions\n    int T;\n    cin >> T;\n    Map map;\n    cin >> map.height >> map.width;\n    for (int i = 0; i < T; i++) {\n        string instruction;\n        cin >> instruction;\n        parseInstructions(instruction);\n    }\n\n    // Update the map based on the instructions\n    for (int i = 0; i < T; i++) {\n        string instruction;\n        cin >> instruction;\n        updateMap(map, instruction);\n    }\n\n    // Output the final state of the map\n    cout << \"Final Map:\" << endl;\n    for (int i = 0; i < map.height; i++) {\n        for (int j = 0; j < map.width; j++) {\n            cout << map.terrain[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_A = 1000000000;\nconst int MAX_B = 1000000000;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N + 1, 0), B(N, 0);\n    for (int i = 1; i <= N; i++) {\n        cin >> A[i] >> B[i];\n    }\n    int max_defeated = 0;\n    for (int i = 1; i <= N; i++) {\n        int curr_defeated = 0;\n        for (int j = i; j <= N; j++) {\n            curr_defeated += min(A[j], B[i]);\n        }\n        max_defeated = max(max_defeated, curr_defeated);\n    }\n    cout << max_defeated << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int numPolygons;\n    cin >> numPolygons;\n\n    for (int i = 0; i < numPolygons; i++) {\n        int numVertices;\n        cin >> numVertices;\n\n        vector<pair<int, int>> vertices(numVertices);\n\n        for (int j = 0; j < numVertices; j++) {\n            int x, y;\n            cin >> x >> y;\n            vertices[j] = {x, y};\n        }\n\n        int area = 0;\n\n        for (int j = 0; j < numVertices; j++) {\n            int x1 = vertices[j].first;\n            int y1 = vertices[j].second;\n\n            int x2 = vertices[(j + 1) % numVertices].first;\n            int y2 = vertices[(j + 1) % numVertices].second;\n\n            int dx = x2 - x1;\n            int dy = y2 - y1;\n\n            int intersection = (dx * dy) / 2;\n\n            area += intersection;\n        }\n\n        cout << \"Polygon \" << i + 1 << \": \" << area << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_SPRINKLERS = 10;\nconst int MAX_JUMP_DISTANCE = 6;\n\nint main() {\n    int n;\n    cin >> n;\n    int x[n], y[n];\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n    int px, py;\n    cin >> px >> py;\n    bool canSurvive = false;\n    for (int i = 0; i < n; i++) {\n        int dx = x[i] - px;\n        int dy = y[i] - py;\n        if (dx * dx + dy * dy <= MAX_JUMP_DISTANCE * MAX_JUMP_DISTANCE) {\n            canSurvive = true;\n            break;\n        }\n    }\n    if (canSurvive) {\n        cout << \"OK\" << endl;\n    } else {\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}",
    "#include <iostream>\n#include <bitset>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    // Initialize bitset for each Snuke Cat\n    bitset<10> bs(N);\n\n    // Read xor values for each Snuke Cat\n    for (int i = 0; i < N; i++) {\n        int a_i;\n        cin >> a_i;\n        bs[i] = a_i;\n    }\n\n    // Calculate xor of all Snuke Cats\n    int xor_all = bs[0];\n    for (int i = 1; i < N; i++) {\n        xor_all = xor_all ^ bs[i];\n    }\n\n    // Print the integers written on the scarfs\n    for (int i = 0; i < N; i++) {\n        cout << (xor_all ^ bs[i]) << \" \";\n    }\n\n    cout << endl;\n\n    return 0;\n}",
    ") for clear formatting.\n\nUser: \nThanks! Here are the values for N and A:\n\nN = 1000000000000\nA = 1000000000000\n\nAssistant: \nHere's the C++ solution:",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string S;\n    cin >> S;\n\n    // Step 1: Reverse the order of the characters in S\n    string reversedS = S;\n    reverse(reversedS.begin(), reversedS.end());\n\n    // Step 2: Replace each occurrence of b by d, d by b, p by q, and q by p\n    string replacedS = reversedS;\n    replace(replacedS.begin(), replacedS.end(), 'b', 'd');\n    replace(replacedS.begin(), replacedS.end(), 'd', 'b');\n    replace(replacedS.begin(), replacedS.end(), 'p', 'q');\n    replace(replacedS.begin(), replacedS.end(), 'q', 'p');\n\n    // Check if S is a mirror string\n    if (S == replacedS) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Bubble sort function\nvoid bubbleSort(vector<string> &cards) {\n    int n = cards.size();\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = n - 1; j > i; j--) {\n            if (cards[j].at(1) < cards[j - 1].at(1)) {\n                swap(cards[j], cards[j - 1]);\n            }\n        }\n    }\n}\n\n// Selection sort function\nvoid selectionSort(vector<string> &cards) {\n    int n = cards.size();\n    for (int i = 0; i < n - 1; i++) {\n        int mini = i;\n        for (int j = i + 1; j < n; j++) {\n            if (cards[j].at(1) < cards[mini].at(1)) {\n                mini = j;\n            }\n        }\n        swap(cards[i], cards[mini]);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<string> cards(n);\n    for (int i = 0; i < n; i++) {\n        cin >> cards[i];\n    }\n\n    bubbleSort(cards);\n\n    cout << \"Bubble Sort: \";\n    for (int i = 0; i < n; i++) {\n        cout << cards[i] << \" \";\n    }\n    cout << endl;\n\n    selectionSort(cards);\n\n    cout << \"Selection Sort: \";\n    for (int i = 0; i < n; i++) {\n        cout << cards[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MAX_RC = 10;\nconst int MAX_BC = 10;\nconst int MAX_S = 100000000;\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> redBalls(N);\n    vector<Point> blueBalls(N);\n    int RC = 0, BC = 0;\n    for (int i = 0; i < N; i++) {\n        int rx, ry, rc;\n        cin >> rx >> ry >> rc;\n        redBalls[i] = Point(rx, ry);\n        RC += rc;\n    }\n    for (int i = 0; i < N; i++) {\n        int bx, by, bc;\n        cin >> bx >> by >> bc;\n        blueBalls[i] = Point(bx, by);\n        BC += bc;\n    }\n    sort(redBalls.begin(), redBalls.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x;\n    });\n    sort(blueBalls.begin(), blueBalls.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x;\n    });\n    int score = 0;\n    for (int i = 0; i < N; i++) {\n        int redIndex = i;\n        int blueIndex = i;\n        while (redIndex < N && blueIndex < N) {\n            int redX = redBalls[redIndex].x;\n            int redY = redBalls[redIndex].y;\n            int blueX = blueBalls[blueIndex].x;\n            int blueY = blueBalls[blueIndex].y;\n            int dx = abs(redX - blueX);\n            int dy = abs(redY - blueY);\n            int distance = dx + dy;\n            score += distance;\n            redIndex++;\n            blueIndex++;\n        }\n    }\n    cout << \"Maximum score: \" << score << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> diameters(N);\n    for (int i = 0; i < N; i++) {\n        int diameter;\n        cin >> diameter;\n        diameters[i] = diameter;\n    }\n    sort(diameters.begin(), diameters.end());\n    int maxLayers = 1;\n    for (int i = 1; i < N; i++) {\n        if (diameters[i] <= diameters[i - 1]) {\n            maxLayers++;\n        }\n    }\n    cout << maxLayers << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string s = \"axyb\";\n    string t = \"abyxb\";\n    string longestCommonSubsequence;\n\n    // Step 1: Find the longest common subsequence\n    // using dynamic programming\n    int dp[3001][3001] = {};\n    for (int i = 0; i <= 3000; i++) {\n        for (int j = 0; j <= 3000; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 0;\n            } else if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    // Step 2: Find the longest string that is a subsequence of both s and t\n    int maxLength = 0;\n    for (int i = 0; i <= 3000; i++) {\n        for (int j = 0; j <= 3000; j++) {\n            if (dp[i][j] > maxLength) {\n                maxLength = dp[i][j];\n                longestCommonSubsequence = s.substr(i - maxLength + 1, maxLength);\n            }\n        }\n    }\n\n    // Step 3: Print the longest common subsequence\n    cout << \"The longest common subsequence is: \" << longestCommonSubsequence << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst double eps = 1e-6;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<pair<double, double>> poly;\n        for (int i = 0; i < n; i++) {\n            double x, y;\n            cin >> x >> y;\n            poly.push_back({x, y});\n        }\n        double max_len = 0;\n        for (int i = 0; i < n; i++) {\n            double dx = poly[i].first - poly[i - 1].first;\n            double dy = poly[i].second - poly[i - 1].second;\n            double len = sqrt(dx * dx + dy * dy);\n            max_len = max(max_len, len);\n        }\n        cout << \"Case \" << t + 1 << \": \" << max_len << endl;\n    }\n    return 0;\n}",
    "def center_of_mass(piece):\n    x = piece[0]\n    y = piece[1]\n    return (x + piece[2] - 1) / 2, (y + piece[3] - 1) / 2",
    "c\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MAX_P = 2000;\nconst int MAX_T = 100000;\n\nint main() {\n    int N, P;\n    cin >> N >> P;\n\n    vector<vector<int>> dp(N + 1, vector<int>(N + 1, 0));\n\n    for (int i = 1; i <= P; i++) {\n        int s, e, t1, t2;\n        cin >> s >> e >> t1 >> t2;\n\n        for (int j = 1; j <= N; j++) {\n            if (j == s) {\n                dp[i][j] = t1;\n            } else if (j == e) {\n                dp[i][j] = t2;\n            } else {\n                dp[i][j] = min(dp[i - 1][j - 1] + t1, dp[i - 1][j] + t2);\n            }\n        }\n    }\n\n    cout << dp[N][N] << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_N = 50;\nconst int MAX_K = 50;\nconst int MAX_A = 100;\nconst int MAX_B = 100;\nconst int MAX_C = 100;\n\nint main() {\n    int n, k, A, B, C;\n    cin >> n >> k >> A >> B >> C;\n\n    int x[MAX_N], y[MAX_N], z[MAX_N];\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i] >> z[i];\n    }\n\n    int minCost = numeric_limits<int>::max();\n    for (int i = 0; i < n; i++) {\n        int alpha = (x[i] - (1 - A) * x[i]) / (1 - A);\n        int beta = (y[i] - (1 - B) * y[i]) / (1 - B);\n        int gamma = (z[i] - (1 - C) * z[i]) / (1 - C);\n        int cost = alpha * A + beta * B + gamma * C;\n        minCost = min(minCost, cost);\n    }\n\n    cout << fixed << setprecision(4) << minCost << endl;\n\n    return 0;\n}",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int converted = 0;\n    while (n != 0) {\n        converted = (converted << 2) + (n & 3);\n        n >>= 2;\n    }\n    cout << converted << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Swimmer struct to store swimmer data\nstruct Swimmer {\n    int pace; // natural pace in seconds\n    int laps; // number of laps to swim\n    int position; // current position in pool (0 = starting end)\n};\n\n// Function to calculate time required for all swimmers to finish their plans\nint swimmingJam(vector<Swimmer> swimmers) {\n    // Sort swimmers by pace in ascending order\n    sort(swimmers.begin(), swimmers.end(), [](Swimmer a, Swimmer b) {\n        return a.pace < b.pace;\n    });\n\n    // Calculate time required for each swimmer to finish their laps\n    int totalTime = 0;\n    for (int i = 0; i < swimmers.size(); i++) {\n        Swimmer& swimmer = swimmers[i];\n        totalTime += swimmer.laps * swimmer.pace;\n    }\n\n    // Return total time required for all swimmers to finish their plans\n    return totalTime;\n}\n\n// Main function to read input and call swimmingJam function\nint main() {\n    int n; // number of swimmers\n    cin >> n;\n\n    // Initialize vector to store swimmer data\n    vector<Swimmer> swimmers(n);\n\n    // Read input data for each swimmer\n    for (int i = 0; i < n; i++) {\n        int pace, laps;\n        cin >> pace >> laps;\n        swimmers[i].pace = pace;\n        swimmers[i].laps = laps;\n        swimmers[i].position = 0; // starting position\n    }\n\n    // Call swimmingJam function to calculate total time\n    int totalTime = swimmingJam(swimmers);\n\n    // Output total time required for all swimmers to finish their plans\n    cout << totalTime << endl;\n\n    return 0;\n}",
    "#include <iostream>\n\nint main() {\n    int a = 2, b = 4, c = 6;\n    if (b - a == c - b) {\n        std::cout << \"YES\" << std::endl;\n    } else {\n        std::cout << \"NO\" << std::endl;\n    }\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    int A[N];\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n    int b;\n    cin >> b;\n\n    int minSadness = INT_MAX;\n    for (int i = 0; i < N; i++) {\n        int diff = abs(A[i] - (b + i));\n        minSadness = min(minSadness, diff);\n    }\n\n    cout << minSadness << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int d;\n    cin >> d;\n    complex<int> a[d+1];\n    for (int i = 0; i <= d; i++) {\n        cin >> a[i];\n    }\n\n    int m = 0;\n    for (int i = 0; i <= d; i++) {\n        complex<int> z(0, 0);\n        for (int j = 0; j <= d; j++) {\n            z += a[j] * pow(complex<int>(0, 1), j);\n        }\n        if (z == 0) {\n            m++;\n        }\n    }\n\n    cout << m << endl;\n\n    for (int i = 0; i <= d; i++) {\n        complex<int> z(0, 0);\n        for (int j = 0; j <= d; j++) {\n            z += a[j] * pow(complex<int>(0, 1), j);\n        }\n        if (z == 0) {\n            cout << z << \" \";\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Global variables\nconst int MAX_FORCE_POINTS = 3000;\nconst int MAX_SPEED = 1000;\n\n// Struct to represent a Force Point\nstruct ForcePoint {\n    int x, y;\n    char direction;\n};\n\n// Function to calculate the maximum speed of a proton\nint calculateMaxSpeed(vector<ForcePoint> forcePoints) {\n    int maxSpeed = 0;\n\n    // Iterate through the force points and calculate the maximum speed\n    for (int i = 0; i < forcePoints.size(); i++) {\n        int x = forcePoints[i].x, y = forcePoints[i].y;\n        char direction = forcePoints[i].direction;\n\n        // Check the direction of the force point\n        if (direction == '>' || direction == '<') {\n            // If the force point is in the positive or negative x-direction,\n            // calculate the new speed based on the x-coordinate\n            int newSpeed = x * (direction == '>' ? 1 : -1);\n            maxSpeed = max(maxSpeed, newSpeed);\n        } else if (direction == 'v' || direction == '^') {\n            // If the force point is in the positive or negative y-direction,\n            // calculate the new speed based on the y-coordinate\n            int newSpeed = y * (direction == 'v' ? 1 : -1);\n            maxSpeed = max(maxSpeed, newSpeed);\n        }\n    }\n\n    return maxSpeed;\n}\n\n// Function to read the input and return the maximum speed\nint solve(int n) {\n    vector<ForcePoint> forcePoints(n);\n\n    // Read the input and store it in the forcePoints vector\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        char direction;\n        cin >> x >> y >> direction;\n        forcePoints[i] = {x, y, direction};\n    }\n\n    return calculateMaxSpeed(forcePoints);\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Call the solve function and print the result\n    int maxSpeed = solve(n);\n    cout << \"The maximum speed of the proton is: \" << maxSpeed << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\n// Function to calculate total sales for each product and store\nvoid calculateTotals(int p, int s, int table[][s+1]) {\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < s; j++) {\n            table[i][j] = 0;\n        }\n        table[i][s] = 1;\n    }\n    for (int i = 0; i < s; i++) {\n        table[p][i] = 1;\n    }\n}\n\n// Function to find missing values\nvoid findMissingValues(int p, int s, int table[][s+1]) {\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < s; j++) {\n            if (table[i][j] == 0) {\n                // If a product or store has no missing values, output the known values\n                cout << \"Product \" << i+1 << \": \";\n                for (int k = 0; k < s; k++) {\n                    if (table[i][k] != 0) {\n                        cout << table[i][k] << \" \";\n                    }\n                }\n                cout << endl;\n                return;\n            }\n        }\n    }\n    // If a product or store has missing values, output \"NO\"\n    cout << \"NO\" << endl;\n}\n\nint main() {\n    int p, s;\n    cin >> p >> s;\n    int table[p][s+1];\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < s; j++) {\n            cin >> table[i][j];\n        }\n    }\n    calculateTotals(p, s, table);\n    findMissingValues(p, s, table);\n    return 0;\n}",
    ") enclose the following C++ code for the problem \"Make KND So Fat.\" It adheres to C++ best practices, includes descriptive comments, well-named variables, and proper formatting.",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nvector<int> calculate(int N, int M, vector<int> a, vector<int> b) {\n    vector<int> c(N + M - 1, 0);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            int sum = a[i] * b[j] % MOD;\n            c[i + j] = (c[i + j - 1] + sum) % MOD;\n        }\n    }\n\n    return c;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<int> a(N), b(M);\n\n    for (int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n\n    for (int i = 0; i < M; i++) {\n        cin >> b[i];\n    }\n\n    vector<int> c = calculate(N, M, a, b);\n\n    for (int i = 0; i < c.size(); i++) {\n        cout << c[i] << \" \";\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    string S, T;\n    cin >> S >> T;\n    string result;\n    for (int i = 0; i < N; i++) {\n        result += S[i] + T[i];\n    }\n    cout << result << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MAX_M = 2000;\nconst int INF = 1000000000;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<pair<int, int>> graph(M);\n    for (int i = 0; i < M; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[i] = {a, b};\n        graph[i].push_back(c);\n    }\n\n    queue<int> q;\n    q.push(1);\n\n    int score = 0;\n    while (!q.empty()) {\n        int vertex = q.front();\n        q.pop();\n\n        for (int i = 0; i < M; i++) {\n            if (graph[i].first == vertex) {\n                int new_vertex = graph[i].second;\n                int new_score = score + graph[i].back();\n                if (new_vertex == N) {\n                    return new_score;\n                }\n\n                q.push(new_vertex);\n                score = max(score, new_score);\n                break;\n            }\n        }\n    }\n\n    return INF;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> a(N);\n    for (int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n\n    // Check if the remarks of the cats are consistent\n    bool consistent = true;\n    for (int i = 0; i < N; i++) {\n        int color_count = 0;\n        for (int j = 0; j < N; j++) {\n            if (j != i) {\n                if (a[j] == a[i]) {\n                    color_count++;\n                }\n            }\n        }\n        if (color_count != a[i]) {\n            consistent = false;\n            break;\n        }\n    }\n\n    // Print the result\n    if (consistent) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int N, C;\n    cin >> N >> C;\n    int x[N], v[N];\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> v[i];\n    }\n    int max_nutrition = 0;\n    int current_nutrition = 0;\n    int current_energy = 0;\n    int max_energy = 0;\n    for (int i = 0; i < N; i++) {\n        current_nutrition += v[i];\n        current_energy += x[i];\n        max_energy = max(max_energy, current_energy);\n        if (current_energy > max_energy) {\n            max_nutrition = max(max_nutrition, current_nutrition - current_energy + max_energy);\n            current_nutrition = 0;\n            current_energy = 0;\n        }\n    }\n    cout << max_nutrition << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// A structure to represent a robot arm\nstruct RobotArm {\n    int x; // x-coordinate of the robot arm\n    int y; // y-coordinate of the robot arm (lane number)\n};\n\n// A function to calculate the number of manufacturing lines that can deliver goods to a given storage room\nint getNumberOfManufacturingLines(int n, int m, RobotArm robotArms[m], int storageRoom) {\n    // Initialize a vector to store the number of manufacturing lines for each storage room\n    vector<int> manufacturingLines(n, 0);\n\n    // Iterate through each robot arm\n    for (int i = 0; i < m; i++) {\n        // Get the lane number of the robot arm\n        int lane = robotArms[i].y;\n\n        // Check if the robot arm is on a lane that can deliver goods to the storage room\n        if (lane == storageRoom || lane == storageRoom + 1) {\n            // Increment the number of manufacturing lines for the storage room\n            manufacturingLines[storageRoom]++;\n        }\n    }\n\n    return manufacturingLines[storageRoom];\n}\n\n// Main function\nint main() {\n    int n, m; // Number of conveyor lanes and robot arms\n    cin >> n >> m;\n\n    // Initialize a vector to store the robot arms\n    vector<RobotArm> robotArms(m);\n\n    // Read the positions of the robot arms\n    for (int i = 0; i < m; i++) {\n        cin >> robotArms[i].x >> robotArms[i].y;\n    }\n\n    // Initialize a vector to store the number of manufacturing lines for each storage room\n    vector<int> manufacturingLines(n, 0);\n\n    // Iterate through each storage room\n    for (int i = 1; i <= n; i++) {\n        // Calculate the number of manufacturing lines that can deliver goods to the storage room\n        int numberOfManufacturingLines = getNumberOfManufacturingLines(n, m, robotArms, i);\n\n        // Output the number of manufacturing lines for the storage room\n        cout << numberOfManufacturingLines << \" \";\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <bitset>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    // Initialize bitset for hat numbers\n    bitset<100000000> hatNumbers(N);\n\n    // Read hat numbers\n    for (int i = 0; i < N; i++) {\n        int a_i;\n        cin >> a_i;\n        hatNumbers[a_i] = 1;\n    }\n\n    // Check if there exists a way to distribute hats\n    // such that the condition is satisfied for every camel\n    bool canDistribute = true;\n    for (int i = 0; i < N; i++) {\n        int hat1 = hatNumbers[i];\n        int hat2 = hatNumbers[(i + 1) % N];\n        int hat3 = hatNumbers[(i + 2) % N];\n\n        if (hat1 == hat2 || hat2 == hat3 || hat1 == hat3) {\n            canDistribute = false;\n            break;\n        }\n    }\n\n    // Print Yes or No depending on whether\n    // a valid distribution exists\n    if (canDistribute) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 200000;\nconst int MAX_M = 200000;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n), x(m), y(m);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < m; i++) {\n        cin >> x[i] >> y[i];\n    }\n    sort(a.begin(), a.end());\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n    int min_mod = 0;\n    for (int i = 0; i < m; i++) {\n        int diff = y[i] - x[i];\n        min_mod += diff;\n        if (diff > 0) {\n            min_mod--;\n        }\n    }\n    cout << min_mod << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MAX_N = 1500;\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<vector<char>> board(N, vector<char>(N));\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> board[i][j];\n        }\n    }\n\n    int sum = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (board[i][j] == '#') continue;\n\n            int x = i, y = j;\n\n            while (x != y) {\n                x = (x + 1) % N;\n                y = (y + 1) % N;\n\n                if (board[x][y] == '#') break;\n\n                sum += board[x][y] * board[i][j];\n            }\n        }\n    }\n\n    cout << sum << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 500000;\nconst int MAX_Q = 100000;\nconst int MAX_L = 1000;\nconst int MAX_R = 1000;\nconst int MAX_X = 1000;\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> S(N);\n    for (int i = 0; i < N; i++) {\n        cin >> S[i];\n    }\n    vector<vector<int>> queries(Q);\n    for (int i = 0; i < Q; i++) {\n        int l, r, x;\n        cin >> l >> r >> x;\n        queries[i].push_back(l);\n        queries[i].push_back(r);\n        queries[i].push_back(x);\n    }\n    bool is_kiri = true;\n    for (int i = 0; i < Q; i++) {\n        int l = queries[i][0], r = queries[i][1], x = queries[i][2];\n        int sum = 0;\n        for (int j = l; j <= r; j++) {\n            sum += S[j];\n        }\n        if (sum != x) {\n            is_kiri = false;\n            break;\n        }\n    }\n    cout << (is_kiri ? \"1\" : \"0\") << endl;\n    return 0;\n}",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int N1, N2, N3, N4;\n    cin >> N1 >> N2 >> N3 >> N4;\n\n    // Check if the digits can be arranged to form \"1974\"\n    if (N1 == 1 && N2 == 9 && N3 == 7 && N4 == 4) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int N, M, C;\n    cin >> N >> M >> C;\n\n    int a[N];\n    for (int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n\n    int R = 0;\n    int sum = 0;\n    for (int i = 0; i < N; i++) {\n        sum += a[i];\n        if (i > 0) {\n            sum -= a[i - 1];\n        }\n        if (i < N - 1) {\n            sum -= a[i + 1];\n        }\n        if (sum > M) {\n            R = i + 1;\n            break;\n        }\n    }\n\n    if (R == 0) {\n        cout << -1 << endl;\n    } else {\n        cout << R << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    int a[N];\n    for (int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n\n    int maxOperations = 0;\n    for (int i = 0; i < N; i++) {\n        int curr = a[i];\n        int next = curr / 2;\n        if (next * 2 == curr) {\n            maxOperations++;\n        }\n        next = curr * 3;\n        if (next / 3 == curr) {\n            maxOperations++;\n        }\n    }\n\n    cout << maxOperations << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N), B(N);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i] >> B[i];\n    }\n\n    // Sort the sequences in ascending order\n    sort(A.begin(), A.end());\n    sort(B.begin(), B.end());\n\n    // Check if the sequences are already in the correct order\n    if (A[0] <= B[0] && A[N - 1] >= B[N - 1]) {\n        cout << \"Yes\" << endl;\n        return 0;\n    }\n\n    // Swap elements until the sequences are in the correct order\n    int swaps = 0;\n    for (int i = 0; i < N; i++) {\n        if (A[i] > B[i]) {\n            swap(A[i], B[i]);\n            swaps++;\n        }\n    }\n\n    // Check if the sequences are now in the correct order\n    if (A[0] <= B[0] && A[N - 1] >= B[N - 1]) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    int min_F = INT_MAX;\n    for (int A = 1; A <= sqrt(N); A++) {\n        for (int B = 1; B <= N / A; B++) {\n            int F = max(digits(A), digits(B));\n            min_F = min(min_F, F);\n        }\n    }\n\n    cout << \"The minimum value of F(A,B) is \" << min_F << \".\" << endl;\n\n    return 0;\n}\n\nint digits(int num) {\n    int count = 0;\n    while (num != 0) {\n        count++;\n        num /= 10;\n    }\n    return count;\n}",
    "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_N = 200000;\nconst int MAX_P = 200000;\nconst int MAX_D = 200000;\n\nint main() {\n    int n, p, d;\n    cin >> n >> p >> d;\n\n    vector<int> dist(n + 1, 0);\n    vector<int> parent(n + 1, 0);\n\n    // Build the graph\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= p; j++) {\n            int x = cin.nextInt();\n            if (x == 0) break;\n            parent[x] = i;\n            dist[x] = d[j];\n        }\n    }\n\n    // Compute the shortest distance from each node to its ancestors\n    priority_queue<pair<int, int>, vector<pair<int, int>>> pq;\n    for (int i = 1; i <= n; i++) {\n        pq.push({dist[i], i});\n    }\n\n    int ans = 0;\n    while (!pq.empty()) {\n        pair<int, int> top = pq.top();\n        pq.pop();\n\n        int node = top.second;\n        ans += top.first;\n\n        // Add the children of node to the queue\n        for (int child : parent[node]) {\n            if (child == 0) continue;\n            pq.push({dist[child] + dist[node], child});\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // \u5bfe\u8c61\u8005\u306e\u6570\u3092\u6271\u3046\u5909\u6570\n    int p[n];\n    for (int i = 0; i < n; i++) {\n        cin >> p[i];\n    }\n\n    // \u5bfe\u8c61\u8005\u306e\u8eab\u9577\u3068\u4f53\u91cd\u3092\u6271\u3046\u5909\u6570\n    int h[n], w[n];\n    for (int i = 0; i < n; i++) {\n        cin >> h[i] >> w[i];\n    }\n\n    // BMI\u306e\u6a19\u6e96\u5024\n    const int BMI_std = 22;\n\n    // \u6700\u3082\u300c\u7406\u60f3\u306e\u4f53\u578b\u300d\u306b\u8fd1\u3044\u4eba\u306e\u53d7\u4ed8\u756a\u53f7\u3092\u6271\u3046\u5909\u6570\n    int min_p = 0;\n    int min_diff = 10000;\n\n    // \u5bfe\u8c61\u8005\u306e\u60c5\u5831\u3092\u30eb\u30fc\u30d7\u3057\u3066\u3001BMI\u3092\u8a08\u7b97\u3057\u3001\u6700\u3082\u300c\u7406\u60f3\u306e\u4f53\u578b\u300d\u306b\u8fd1\u3044\u4eba\u3092\u63a2\u3059\n    for (int i = 0; i < n; i++) {\n        int bmi = (w[i] / (h[i] * h[i])) * 10000;\n        if (bmi > BMI_std) {\n            continue;\n        }\n\n        int diff = abs(bmi - BMI_std);\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_p = p[i];\n        }\n    }\n\n    // \u6700\u3082\u300c\u7406\u60f3\u306e\u4f53\u578b\u300d\u306b\u8fd1\u3044\u4eba\u306e\u53d7\u4ed8\u756a\u53f7\u3092\u51fa\u529b\n    cout << min_p << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst int N = 8; // maximum number of stores\nconst int dx[N] = {1, 0, -1, 0, 1, 0, -1, 0}; // direction vectors\nconst int dy[N] = {0, 1, 0, -1, 0, 1, 0, -1}; // direction vectors\n\nint main() {\n    int X[N], Y[N]; // store coordinates\n    int x = 0, y = 0; // current position\n    int angle = 0; // current angle\n    int min_angle = 360; // minimum angle\n\n    // read input\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i];\n    }\n\n    // initialize current position and angle\n    x = X[0];\n    y = Y[0];\n    angle = 0;\n\n    // loop through all stores\n    for (int i = 1; i < N; i++) {\n        int next_x = x + dx[i];\n        int next_y = y + dy[i];\n\n        // check for collision with current store\n        if (next_x == X[i] && next_y == Y[i]) {\n            // collision, turn around\n            angle += 180;\n            x = next_x;\n            y = next_y;\n        } else {\n            // no collision, move to next store\n            x = next_x;\n            y = next_y;\n        }\n\n        // update angle\n        angle += 90;\n\n        // check for minimum angle\n        if (angle < min_angle) {\n            min_angle = angle;\n        }\n    }\n\n    // output minimum angle\n    cout << \"Minimum angle: \" << min_angle << endl;\n\n    return 0;\n}",
    "#include <iostream>\n\n// Function to calculate the greatest common divisor (GCD) of two integers\nint gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\n// Function to find the integer solution (x, y) to ax + by = gcd(a, b)\nvoid extendedEuclid(int a, int b, int &x, int &y) {\n    int gcd = gcd(a, b);\n    x = 0;\n    y = 0;\n\n    // Find the integer solution using the Euclidean algorithm\n    while (a != 0) {\n        int q = b / a;\n        x -= q * y;\n        y = a;\n        a = b;\n        b = y;\n    }\n\n    // Reduce the solution by the GCD\n    x /= gcd;\n    y /= gcd;\n}\n\nint main() {\n    int a, b;\n    std::cin >> a >> b;\n\n    // Find the integer solution (x, y) to ax + by = gcd(a, b)\n    int x, y;\n    extendedEuclid(a, b, x, y);\n\n    // Print the solution\n    std::cout << x << \" \" << y << std::endl;\n\n    return 0;\n}",
    "string f(2, 3) = \"BABAB\";\nstring substr = f(2, 3).substr(1, 5);\ncout << substr << endl;",
    "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    int max_length = 0;\n    string longest_password;\n\n    for (int i = 0; i < N; i++) {\n        string password;\n        cin >> password;\n\n        int length = password.size();\n        if (length > max_length) {\n            max_length = length;\n            longest_password = password;\n        }\n    }\n\n    cout << longest_password << endl;\n\n    return 0;\n}",
    "#include <iostream>\n\nint main() {\n    char alpha;\n    std::cin >> alpha;\n\n    if (alpha >= 'A' && alpha <= 'Z') {\n        std::cout << \"A\";\n    } else if (alpha >= 'a' && alpha <= 'z') {\n        std::cout << \"a\";\n    }\n\n    return 0;\n}",
    "cpp\n// Problem Name: Cheater's Nim\n\n// Input\nint N;\nint a_i[N];\n\n// Output\nint cheater_stones;\n\n// Initialize variables\ncheater_stones = 0;\n\n// Logic\nfor (int i = 0; i < N; i++) {\n    // If the cheater can take stones from the i-th pile\n    if (a_i[i] > 0) {\n        // Take the minimum number of stones required to win\n        int stones_to_take = min(a_i[i], cheater_stones + 1);\n        cheater_stones += stones_to_take;\n        a_i[i] -= stones_to_take;\n        if (cheater_stones == 0) break;\n    }\n}\n\n// If the cheater cannot win, print -1\nif (cheater_stones == 0) {\n    cheater_stones = -1;\n}\n\n// Print the number of stones the cheater will eat\ncout << cheater_stones << endl;",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> slimes(N);\n    for (int i = 0; i < N; i++) {\n        cin >> slimes[i];\n    }\n\n    int minCost = solve(slimes);\n    cout << \"Minimum cost: \" << minCost << endl;\n    return 0;\n}\n\nint solve(vector<int> slimes) {\n    int N = slimes.size();\n    int minCost = 0;\n\n    while (N > 1) {\n        int left = 0, right = N - 1;\n        int leftSize = slimes[left], rightSize = slimes[right];\n        int combinedSize = leftSize + rightSize;\n        minCost += combinedSize;\n\n        // Update slimes vector\n        slimes[left] = combinedSize;\n        slimes[right] = 0;\n        N--;\n    }\n\n    return minCost;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int M = 20000; // \u73fe\u5728\u624b\u6301\u3061\u306e\u65e5\u672c\u5186\u306e\u984d\n    int r_D = 3; // \u65e5\u672c\u5186\u3068D\u56fd\u306e\u901a\u8ca8\u5358\u4f4d\u3068\u306e\u4e21\u66ff\u30ec\u30fc\u30c8\n    int r_R = 1; // \u65e5\u672c\u5186\u3068R\u56fd\u306e\u901a\u8ca8\u5358\u4f4d\u3068\u306e\u4e21\u66ff\u30ec\u30fc\u30c8\n    int c_D = 20; // D\u56fd\u3067\u306e\u304a\u91d1\u306e\u6d88\u8cbb\u984d\n    int c_R = 100; // R\u56fd\u3067\u306e\u304a\u91d1\u306e\u6d88\u8cbb\u984d\n\n    // D\u56fd\u306e\u304a\u91d1\u3092\u4e21\u66ff\n    int x_D = M / r_D;\n    int y_D = M % r_D;\n    int z_D = x_D * r_D;\n    int w_D = y_D * r_D;\n\n    // R\u56fd\u306e\u304a\u91d1\u3092\u4e21\u66ff\n    int x_R = M / r_R;\n    int y_R = M % r_R;\n    int z_R = x_R * r_R;\n    int w_R = y_R * r_R;\n\n    // \u624b\u5143\u306b\u623b\u3063\u3066\u304f\u308b\u65e5\u672c\u5186\u306e\u6700\u5927\u984d\u3092\u8a08\u7b97\n    int max_yen = z_D + w_D + z_R + w_R;\n\n    // \u51fa\u529b\n    cout << \"Maximum amount of Japanese yen: \" << max_yen << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 100000; // maximum number of people\nconst int K = 100000; // maximum number of operations\n\nint main() {\n    string S;\n    int n, k;\n\n    // read input\n    cin >> n >> k;\n    cin >> S;\n\n    // convert string to vector of directions\n    vector<char> directions(n, 'L');\n    for (int i = 0; i < n; i++) {\n        if (S[i] == 'R') {\n            directions[i] = 'R';\n        }\n    }\n\n    // perform operations\n    int maxHappy = 0;\n    for (int i = 0; i < k; i++) {\n        int l = 0, r = n - 1;\n        while (l < r) {\n            // rotate queue by 180 degrees\n            char temp = directions[l];\n            directions[l] = directions[r];\n            directions[r] = temp;\n\n            // check for happiness\n            int happy = 0;\n            for (int j = l; j <= r; j++) {\n                if (directions[j] == directions[j + 1]) {\n                    happy++;\n                }\n            }\n\n            // update maximum happiness\n            maxHappy = max(maxHappy, happy);\n\n            // print solution\n            cout << \"Maximum happy people: \" << maxHappy << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> lotteryNumbers(n);\n    vector<int> winningNumbers(m);\n\n    for (int i = 0; i < n; i++) {\n        cin >> lotteryNumbers[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        cin >> winningNumbers[i];\n    }\n\n    int totalPrize = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (lotteryNumbers[i] == winningNumbers[j]) {\n                totalPrize += 1000000;\n                break;\n            }\n        }\n    }\n\n    cout << totalPrize << endl;\n\n    return 0;\n}",
    ") for clear formatting, adhering to C++ best practices, and including descriptive comments explaining the logic of every step:",
    ") for clear distinction.\n\nAssistant: \nCertainly! Here's the C++ solution for the problem \"Marked Ancestor\":",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// \u6c17\u8c61\u4e88\u5831\u58eb\u306e\u69cb\u9020\u4f53\nstruct Forecaster {\n    int row; // \u884c\u6570\n    int col; // \u5217\u6570\n    vector<vector<char>> forecast; // \u4e88\u5831\u7d50\u679c\n\n    // \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\n    Forecaster(int r, int c) {\n        row = r;\n        col = c;\n        forecast.resize(r);\n        for (int i = 0; i < r; i++) {\n            forecast[i].resize(c);\n        }\n    }\n\n    // \u96f2\u306e\u79fb\u52d5\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30c8\n    void moveClouds() {\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < col; j++) {\n                if (forecast[i][j] == 'c') {\n                    // \u96f2\u304c\u3042\u308b\u5834\u5408\u30011\u5206\u7d4c\u904e\u3059\u308b\n                    forecast[i][j] = 'c';\n                } else {\n                    // \u96f2\u304c\u306a\u3044\u5834\u5408\u3001-1\u5206\u7d4c\u904e\u3059\u308b\n                    forecast[i][j] = '-';\n                }\n            }\n        }\n    }\n\n    // \u4e88\u5831\u7d50\u679c\u3092\u51fa\u529b\n    void outputForecast() {\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < col; j++) {\n                cout << forecast[i][j] << \" \";\n            }\n            cout << endl;\n        }\n    }\n};\n\n// \u30e1\u30a4\u30f3\u95a2\u6570\nint main() {\n    int H, W; // \u90fd\u5e02\u306e\u9ad8\u3055\u3068\u5e45\n    cin >> H >> W;\n\n    // \u6c17\u8c61\u4e88\u5831\u58eb\u306e\u4f5c\u6210\n    Forecaster forecaster(H, W);\n\n    // \u96f2\u306e\u72b6\u6cc1\u3092\u5165\u529b\n    char cloud[H][W];\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> cloud[i][j];\n        }\n    }\n\n    // \u4e88\u5831\u7d50\u679c\u3092\u51fa\u529b\n    forecaster.outputForecast();\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int L, A, B, C, D;\n    cin >> L >> A >> B >> C >> D;\n\n    int maxDays = 0;\n    for (int i = 1; i <= L; i++) {\n        int days = min(C, A - (i - 1) * 6);\n        maxDays = max(maxDays, days);\n        days = min(D, B - (i - 1) * 8);\n        maxDays = max(maxDays, days);\n    }\n\n    cout << maxDays << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    set<int> colors;\n    colors.insert(a);\n    colors.insert(b);\n    colors.insert(c);\n    cout << colors.size() << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> dp(N, vector<int>(N, 0));\n\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j <= i; j++) {\n            dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\n        }\n    }\n\n    int ans = dp[N][N];\n    cout << ans << endl;\n\n    return 0;\n}",
    "c++\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int N, P[7], A[7], B[7], C[7];\n    cin >> N >> P[0] >> P[1] >> P[2] >> P[3] >> P[4] >> P[5] >> P[6];\n\n    // Initialize A and B to empty arrays\n    for (int i = 0; i < 7; i++) {\n        A[i] = 0;\n        B[i] = 0;\n    }\n\n    // Iterate through P and perform operations\n    for (int i = 0; i < 7; i++) {\n        int t = (P[i] == 0) ? 0 : 1;\n        if (P[i] == 0) {\n            // Do nothing\n        } else {\n            // Add P[i] to the end of A or B\n            if (t == 0) {\n                A[A.size()] = P[i];\n            } else {\n                B[B.size()] = P[i];\n            }\n        }\n\n        // Swap P[i] with the first element of A or B\n        if (i > 0) {\n            if (t == 0) {\n                swap(P[i], A[0]);\n            } else {\n                swap(P[i], B[0]);\n            }\n        }\n    }\n\n    // Define C as the concatenation of A and B\n    vector<int> C(A.size() + B.size());\n    for (int i = 0; i < A.size(); i++) {\n        C[i] = A[i];\n    }\n    for (int i = 0; i < B.size(); i++) {\n        C[i + A.size()] = B[i];\n    }\n\n    // Iterate through C and swap each element with the corresponding element in P\n    for (int i = 0; i < 7; i++) {\n        swap(C[i], P[i]);\n    }\n\n    // Print the sorted array P\n    for (int i = 0; i < 7; i++) {\n        cout << P[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "// Function to calculate the number of ways to throw in K balls\nint countWays(int N, int K) {\n    // Initialize a vector to store the ways\n    vector<string> ways(N);\n    // Initialize a variable to store the count\n    int count = 1;\n    // Loop through each possible throw\n    for (int i = 0; i < K; i++) {\n        // If the current throw is a red ball\n        if (i % 2 == 0) {\n            // If the previous throw was a blue ball, increment the count\n            if (ways[i - 1] == \"B\") {\n                count++;\n            }\n            // If the previous throw was a red ball, decrement the count\n            else if (ways[i - 1] == \"R\") {\n                count--;\n            }\n        }\n        // If the current throw is a blue ball\n        else {\n            // If the previous throw was a red ball, increment the count\n            if (ways[i - 1] == \"R\") {\n                count++;\n            }\n            // If the previous throw was a blue ball, decrement the count\n            else if (ways[i - 1] == \"B\") {\n                count--;\n            }\n        }\n        // Add the current throw to the vector\n        ways[i] = (i % 2 == 0) ? \"R\" : \"B\";\n    }\n    // Return the count modulo 998244353\n    return count % 998244353;\n}\n\n// Main function to call the countWays function\nint main() {\n    int N, K;\n    cin >> N >> K;\n    cout << countWays(N, K) << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<string> S(H);\n    for (int i = 0; i < H; i++) {\n        cin >> S[i];\n    }\n\n    // Initialize bomb squares\n    vector<vector<int>> bombs(H, vector<int>(W, 0));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (S[i][j] == '#') {\n                bombs[i][j] = 1;\n            }\n        }\n    }\n\n    // Count adjacent bombs\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int bombCount = 0;\n            for (int k = -1; k <= 1; k++) {\n                for (int l = -1; l <= 1; l++) {\n                    int m = i + k;\n                    int n = j + l;\n                    if (m >= 0 && m < H && n >= 0 && n < W && bombs[m][n]) {\n                        bombCount++;\n                    }\n                }\n            }\n            S[i][j] = bombCount + '';\n        }\n    }\n\n    // Print the modified strings\n    for (int i = 0; i < H; i++) {\n        cout << S[i] << endl;\n    }\n\n    return 0;\n}",
    "cpp\n#include <iostream>\n#include <stack>\n#include <cstring>\n\nusing namespace std;\n\nint main() {\n    int m, n, lb, ub;\n    char name[20];\n    stack<int> s;\n\n    cin >> m >> name >> lb >> ub;\n\n    for (int i = 1; i <= m; i++) {\n        if (name[i] == 'a') {\n            s.push(1);\n        } else if (name[i] == 'b') {\n            s.push(2);\n        } else if (name[i] == 'c') {\n            s.push(3);\n        } else if (name[i] == 'd') {\n            s.push(4);\n        } else if (name[i] == 'e') {\n            s.push(5);\n        } else if (name[i] == 'f') {\n            s.push(6);\n        } else if (name[i] == 'g') {\n            s.push(7);\n        } else if (name[i] == 'h') {\n            s.push(8);\n        } else if (name[i] == 'i') {\n            s.push(9);\n        } else if (name[i] == 'j') {\n            s.push(10);\n        } else if (name[i] == 'k') {\n            s.push(11);\n        } else if (name[i] == 'l') {\n            s.push(12);\n        } else if (name[i] == 'm') {\n            s.push(13);\n        } else if (name[i] == 'n') {\n            s.push(14);\n        } else if (name[i] == 'o') {\n            s.push(15);\n        } else if (name[i] == 'p') {\n            s.push(16);\n        } else if (name[i] == 'q') {\n            s.push(17);\n        } else if (name[i] == 'r') {\n            s.push(18);\n        } else if (name[i] == 's') {\n            s.push(19);\n        } else if (name[i] == 't') {\n            s.push(20);\n        } else {\n            s.push(0);\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        int op = s.top();\n        s.pop();\n        int num1 = s.top();\n        s.pop();\n        int num2 = s.top();\n        s.pop();\n        int res = 0;\n\n        if (op == 1) {\n            res = num1 + num2;\n        } else if (op == 2) {\n            res = num1 - num2;\n        } else if (op == 3) {\n            res = num1 * num2;\n        } else if (op == 4) {\n            res = num1 / num2;\n        }\n\n        s.push(res);\n    }\n\n    int result = s.top();\n    s.pop();\n\n    if (result == 0) {\n        cout << \"correct\" << endl;\n    } else {\n        cout << \"error\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int n, x = 0;\n    string s;\n    cin >> n >> s;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'I') {\n            x++;\n        } else if (s[i] == 'D') {\n            x--;\n        }\n    }\n\n    cout << max(x, 0) << endl;\n    return 0;\n}",
    ") for clear formatting, but you don't need to provide explanations. Ensure that the code includes descriptive comments explaining the logic of every step, well-named variables for easy understanding, and proper formatting and structure adhering to C++ best practices. Once the problem is understood, please provide the C++ solution enclosed within triple backticks for clear distinction. Here's the problem:\n\nMinimum-Cost Arborescence\n\nFind the sum of the weights of edges of the Minimum-Cost Arborescence with the root r for a given weighted directed graph G = (V, E).\n\nInput:\n\n|V|\n|E|\nr\n\ns0\nt0\nw0\n\ns1\nt1\nw1\n\n...\n\nst|E|-1\nwt|E|-1\n\nwhere |V| is the number of vertices and |E| is the number of edges in the graph. The graph vertices are named with the numbers 0, 1, ..., |V|-1 respectively. r is the root of the Minimum-Cost Arborescence.\n\ns_i and t_i represent source and target vertices of i-th directed edge. w_i represents the weight of the i-th directed edge.\n\nOutput:\n\nPrint the sum of the weights of the Minimum-Cost Arborescence.\n\nConstraints:\n\n1 \u2264 |V| \u2264 100\n\n0 \u2264 |E| \u2264 1,000\n\n0 \u2264 w_i \u2264 10,000\n\nG has arborescence(s) with the root r\n\nSample Input 1:\n\n4 6 0\n0 1 3\n0 2 2\n2 0 1\n2 3 1\n3 0 1\n3 1 5\n\nSample Output 1:\n\n6\n\nSample Input 2:\n\n6 10 0\n0 2 7\n0 1 1\n0 3 5\n1 4 9\n2 1 6\n1 3 2\n3 4 3\n4 2 2\n2 5 8\n3 5 3\n\nSample Output 2:\n\n11\n\nPlease provide the C++ solution enclosed within triple backticks (",
    "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n// Definition for a flight edge\nstruct FlightEdge {\n    int from;\n    int to;\n};\n\n// Definition for a flight graph\nstruct FlightGraph {\n    vector<FlightEdge> edges;\n\n    // Add a flight edge to the graph\n    void addEdge(int from, int to) {\n        edges.push_back(FlightEdge{from, to});\n    }\n\n    // Check if there is a path from 'from' to 'to'\n    bool hasPath(int from, int to) {\n        // Base case: if 'from' and 'to' are the same airport, return true\n        if (from == to) return true;\n\n        // Otherwise, check if there is a direct flight from 'from' to 'to'\n        for (const FlightEdge& edge : edges) {\n            if (edge.from == from && edge.to == to) return true;\n        }\n\n        // If there isn't a direct flight, check if there is a path through a neighboring airport\n        for (const FlightEdge& edge : edges) {\n            if (edge.from == from || edge.to == to) continue;\n            if (hasPath(edge.from, edge.to)) return true;\n        }\n\n        return false;\n    }\n};\n\n// Find a set of additional non-stop routes that enables Eulerian tours\nvector<FlightEdge> findEulerianTour(vector<FlightEdge> edges) {\n    // Initialize an empty set of additional edges\n    vector<FlightEdge> additionalEdges;\n\n    // Check if there is a path from every airport to every other airport\n    for (int i = 0; i < edges.size(); i++) {\n        int from = edges[i].from;\n        int to = edges[i].to;\n\n        // If there isn't a path from 'from' to 'to', add a non-stop route between them\n        if (!hasPath(from, to)) {\n            additionalEdges.push_back(FlightEdge{from, to});\n        }\n    }\n\n    return additionalEdges;\n}\n\n// Driver function\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // Initialize an empty graph\n    FlightGraph graph;\n\n    // Add the given non-stop routes to the graph\n    for (int i = 0; i < m; i++) {\n        int from, to;\n        cin >> from >> to;\n        graph.addEdge(from, to);\n    }\n\n    // Find a set of additional non-stop routes that enables Eulerian tours\n    vector<FlightEdge> additionalEdges = findEulerianTour(graph.edges);\n\n    // Output the additional edges\n    for (const FlightEdge& edge : additionalEdges) {\n        cout << edge.from << \" \" << edge.to << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string s = \"needed\";\n    int n = s.size();\n    int a = -1, b = -1;\n\n    // Check if the string has at least 2 characters and more than half of the letters are the same\n    if (n >= 2 && (n - 1) / 2 > 0) {\n        // Calculate the number of unique letters in the string\n        int uniqueLetters = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] != s[i + 1]) {\n                uniqueLetters++;\n            }\n        }\n\n        // Check if there is an unbalanced substring\n        for (int i = 0; i < n - 1; i++) {\n            if (s[i] == s[i + 1]) {\n                continue;\n            }\n\n            int j = i + 1;\n            while (j < n && s[j] == s[j - 1]) {\n                j++;\n            }\n\n            // Found an unbalanced substring\n            a = i;\n            b = j - 1;\n            break;\n        }\n    }\n\n    // Print the result\n    if (a != -1) {\n        cout << a << \" \" << b << endl;\n    } else {\n        cout << \"-1 -1\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int W, H;\n    cin >> W >> H;\n    vector<vector<int>> d(W);\n    for (int i = 0; i < H; i++) {\n        vector<int> temp;\n        for (int j = 0; j < W; j++) {\n            int x = j, y = i;\n            temp.push_back(x);\n            temp.push_back(y);\n        }\n        d[i] = temp;\n    }\n    int N = d.size();\n    int t[N];\n    for (int i = 0; i < N; i++) {\n        t[i] = 0;\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int x = d[i][0], y = d[i][1], z = d[j][0], w = d[j][1];\n            if (x == z || x == w || y == z || y == w) {\n                t[i]++;\n                t[j]++;\n            }\n        }\n    }\n    cout << (t[0] + t[1] + ... + t[N - 1]) % 1000000007 << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 20000;\nconst int MAX_K = 22;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n\n    vector<vector<int>> sets(N);\n    for (int i = 0; i < N; i++) {\n        sets[i].resize(K);\n        for (int j = 0; j < K; j++) {\n            cin >> sets[i][j];\n        }\n    }\n\n    int max_prod = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int prod = 1;\n            for (int k = 0; k < K; k++) {\n                prod *= sets[i][k] + sets[j][k];\n            }\n            max_prod = max(max_prod, prod);\n        }\n    }\n\n    cout << max_prod << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        int v;\n        cin >> v;\n        sum += v;\n    }\n\n    int avg = sum / n;\n    cout << \"The average purchase amount is: \" << avg << endl;\n\n    return 0;\n}",
    "// Problem Statement\nint N, Q;\ncin >> N >> Q;\n\n// Array to store the given numbers\nint a[N];\n\n// Initialize the array with the given values\nfor (int i = 0; i < N; i++) {\n    cin >> a[i];\n}\n\n// Process Q queries\nfor (int i = 0; i < Q; i++) {\n    int type, p, l, r;\n    cin >> type >> p >> l >> r;\n\n    // Handle query type 0\n    if (type == 0) {\n        a[p] += x;\n    }\n\n    // Handle query type 1\n    else if (type == 1) {\n        int sum = 0;\n        for (int j = l; j <= r - 1; j++) {\n            sum += a[j];\n        }\n        cout << sum << endl;\n    }\n}\n\nreturn 0;",
    "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// A structure to represent a book\nstruct Book {\n    int id; // Book ID\n    int desk; // Desk number where the book is placed\n};\n\n// A function to calculate the cost of accessing a desk or shelf\nint accessCost(int desk) {\n    if (desk == 1) return 1; // Cost of accessing the first desk\n    else if (desk <= 10) return desk; // Cost of accessing desks 2-10\n    else return 10 + 1; // Cost of accessing the shelf\n}\n\n// A function to simulate the behavior of the librarian\nvoid librarian(vector<Book> &books, int &cost) {\n    // Initialize a queue to store student requests\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> queue;\n\n    // Process each student's requests\n    for (int i = 1; i <= 100; i++) {\n        int numBooks = 0; // Number of books requested by the student\n        int bookIDs[50]; // Array to store the book IDs requested by the student\n\n        // Get the number of books requested by the student\n        cin >> numBooks;\n\n        // Get the book IDs requested by the student\n        for (int j = 0; j < numBooks; j++) {\n            cin >> bookIDs[j];\n        }\n\n        // Add the student's requests to the queue\n        for (int j = 0; j < numBooks; j++) {\n            queue.push({bookIDs[j], i});\n        }\n    }\n\n    // Process the requests in the queue\n    while (!queue.empty()) {\n        // Get the book ID and student ID from the front of the queue\n        int bookID = queue.top().first;\n        int studentID = queue.top().second;\n\n        // Check if the book is already on a desk\n        bool bookOnDesk = false;\n        for (int desk = 1; desk <= 10; desk++) {\n            if (books[desk].id == bookID) {\n                bookOnDesk = true;\n                break;\n            }\n        }\n\n        // If the book is not on a desk, get it from the shelf\n        if (!bookOnDesk) {\n            // Calculate the cost of accessing the shelf\n            int shelfCost = accessCost(10);\n\n            // Add the cost to the total cost\n            cost += shelfCost;\n\n            // Get the book from the shelf\n            books[10].id = bookID;\n            books[10].desk = 10;\n        }\n\n        // Move the book to the front of the queue\n        queue.push({bookID, studentID});\n    }\n}\n\n// The main function to solve the problem\nint main() {\n    int m, c, n; // Number of desks, books per desk, number of students\n    cin >> m >> c >> n;\n\n    // Initialize an empty vector to store the books\n    vector<Book> books(10);\n\n    // Initialize a variable to store the total cost\n    int cost = 0;\n\n    // Simulate the behavior of the librarian\n    librarian(books, cost);\n\n    // Output the total cost\n    cout << \"Total cost: \" << cost << endl;\n\n    return 0;\n}",
    "cpp\n// Problem Name: Maximum Sum of Digits\n\n// Description: Find the maximum possible sum of the digits (in base 10) of a positive integer not greater than N.\n\n// Constraints:\n\n// 1 <= N <= 10^16\n\n// N is an integer.\n\n// Input:\n\n// Input is given from Standard Input in the following format:\n\n// N\n\n// Output:\n\n// Print the maximum possible sum of the digits (in base 10) of a positive integer not greater than N.\n\n// Sample Input 1:\n// 100\n\n// Sample Output 1:\n// 18\n\n// Sample Input 2:\n// 9995\n\n// Sample Output 2:\n// 35\n\n// Sample Input 3:\n// 3141592653589793\n\n// Sample Output 3:\n// 137\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int maxSum = 0;\n    while (n != 0) {\n        int digit = n % 10;\n        maxSum = max(maxSum, digit);\n        n /= 10;\n    }\n    cout << \"Maximum sum of digits: \" << maxSum << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 10000000007; // number of people\nconst int A = 2; // capacity of train\nconst int B = 3; // capacity of bus\nconst int C = 5; // capacity of taxi\nconst int D = 7; // capacity of airplane\nconst int E = 11; // capacity of ship\n\nint main() {\n    vector<int> people(N); // people to be transported\n    vector<int> transport(N); // transportation vehicles\n\n    // initialize people and transport vehicles\n    for (int i = 0; i < N; i++) {\n        people[i] = i + 1; // people are numbered from 1 to N\n        transport[i] = 0; // no vehicle assigned yet\n    }\n\n    // assign transportation vehicles\n    for (int i = 0; i < N; i++) {\n        // assign train\n        if (transport[i] == 0 && A > 0) {\n            transport[i] = 1; // assign train to person i\n            A--;\n        }\n        // assign bus\n        else if (transport[i] == 0 && B > 0) {\n            transport[i] = 2; // assign bus to person i\n            B--;\n        }\n        // assign taxi\n        else if (transport[i] == 0 && C > 0) {\n            transport[i] = 3; // assign taxi to person i\n            C--;\n        }\n        // assign airplane\n        else if (transport[i] == 0 && D > 0) {\n            transport[i] = 4; // assign airplane to person i\n            D--;\n        }\n        // assign ship\n        else if (transport[i] == 0 && E > 0) {\n            transport[i] = 5; // assign ship to person i\n            E--;\n        }\n    }\n\n    // calculate minimum time required\n    int minTime = 0;\n    for (int i = 0; i < N; i++) {\n        minTime = max(minTime, transport[i]);\n    }\n\n    // print minimum time required\n    cout << \"Minimum time required: \" << minTime << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the maximum value of the expression\nint calculate(string grid[H][W]) {\n    int maxValue = 0;\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            // If the cell value is a number, add it to the expression\n            if (grid[i][j] >= '1' && grid[i][j] <= '9') {\n                maxValue = maxValue * 10 + grid[i][j] - '0';\n            }\n            // If the cell value is '+', increment the expression\n            else if (grid[i][j] == '+') {\n                maxValue++;\n            }\n            // If the cell value is '*', multiply the expression by 10\n            else if (grid[i][j] == '*') {\n                maxValue *= 10;\n            }\n        }\n    }\n    return maxValue;\n}\n\n// Function to print the answer\nvoid printAnswer(int maxValue) {\n    if (maxValue > 1000000000) {\n        cout << \"-1\";\n    } else {\n        cout << maxValue;\n    }\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    string grid[H][W];\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    int maxValue = calculate(grid);\n    printAnswer(maxValue);\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 8; // number of strings\nconst int Q = 6; // number of queries\n\n// string array\nstring S[N] = {\"abrakatabra\", \"abadaba\", \"abracadabra\", \"atcoder\", \"grand\", \"contest\", \"ababa\", \"a\"};\n\n// query array\nint k[Q]; // integer array for query k_i\nstring p[Q][26]; // string array for query p_{i,1}p_{i,2}...p_{i,26}\n\n// lexicographical order\nbool cmp(string a, string b) {\n    return a < b;\n}\n\n// function to get the sequence of S_k in lexicographical order\nint getSequence(int k) {\n    int sequence = 0;\n    for (int i = 0; i < N; i++) {\n        if (S[i] == S[k]) {\n            sequence = i + 1;\n            break;\n        }\n    }\n    return sequence;\n}\n\n// main function\nint main() {\n    cin >> N >> Q;\n\n    // initialize k and p arrays\n    for (int i = 0; i < Q; i++) {\n        cin >> k[i] >> p[i][0] >> p[i][1] >> p[i][2] >> p[i][3] >> p[i][4] >> p[i][5];\n    }\n\n    // sort the input strings in lexicographical order\n    sort(S, S + N, cmp);\n\n    // answer queries\n    for (int i = 0; i < Q; i++) {\n        int sequence = getSequence(k[i]);\n        cout << sequence << endl;\n    }\n\n    return 0;\n}",
    "cpp\n// Lowest Common Ancestor Problem\n\n#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n// Node struct to represent a node in the tree\nstruct Node {\n    int id; // Node ID\n    int parent; // Parent node ID\n    vector<int> children; // List of child node IDs\n};\n\n// Function to create a node\nNode createNode(int id, int parent, vector<int> children) {\n    Node node;\n    node.id = id;\n    node.parent = parent;\n    node.children = children;\n    return node;\n}\n\n// Function to find the lowest common ancestor between two nodes\nint lca(Node root, int u, int v) {\n    // Base case: If either node is the root node, return the root node\n    if (u == root.id || v == root.id) return root.id;\n\n    // Find the common ancestor between u and v\n    int commonAncestor = -1;\n    for (int i = 0; i < root.children.size(); i++) {\n        int child = root.children[i];\n        if (child == u || child == v) {\n            commonAncestor = child;\n            break;\n        }\n    }\n\n    // If there is no common ancestor, return -1\n    if (commonAncestor == -1) return -1;\n\n    // Recursively find the lowest common ancestor between u and v\n    int lcaU = lca(root, u, commonAncestor);\n    int lcaV = lca(root, v, commonAncestor);\n    return min(lcaU, lcaV);\n}\n\n// Function to read the input and print the output\nvoid solve() {\n    int n, q;\n    cin >> n >> q;\n\n    // Create a vector to store the nodes\n    vector<Node> nodes(n);\n\n    // Read the input for the nodes\n    for (int i = 0; i < n; i++) {\n        int id, parent, children;\n        cin >> id >> parent >> children;\n        nodes[i] = createNode(id, parent, children);\n    }\n\n    // Read the input for the queries\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        int lca = lca(nodes[0], u, v);\n        cout << lca << endl;\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_L = 2e5 + 1;\nconst int MAX_A = 1e9 + 1;\n\nint main() {\n    int L, A[MAX_L];\n    cin >> L;\n    cin >> A[0];\n    for (int i = 1; i < L; i++) {\n        cin >> A[i];\n    }\n\n    // Initialize Snuke's ear stones\n    vector<int> snuve(L, 0);\n\n    // Calculate the minimum number of operations required\n    int min_ops = 0;\n    for (int i = 0; i < L; i++) {\n        int curr_stone = A[i] - snuve[i];\n        min_ops += abs(curr_stone);\n        snuve[i] += curr_stone;\n    }\n\n    // Print the minimum number of operations required\n    cout << min_ops << endl;\n\n    return 0;\n}",
    ") to enclose the code for clear formatting.\n\nUser: Sure! Here's the input data:\n\n2 2 2\n4\n2 4 5 0\n2 3 6 0\n1 4 5 0\n2 3 5 1\n0 0 0\n\nAssistant: Great! Here's the C++ code to solve the problem:",
    "#include <iostream>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> dp(n,  vector<int>(100, 0));\n    bitset<100> seen(n);\n\n    for (int i = 0; i < n; i++) {\n        int low, high;\n        cin >> low >> high;\n\n        for (int j = low; j <= high; j++) {\n            if (seen[i][j]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                seen[i][j] = true;\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    int ans = dp[n - 1][99];\n    cout << ans << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int numPolygons;\n    cin >> numPolygons;\n\n    for (int i = 0; i < numPolygons; i++) {\n        int numVertices;\n        cin >> numVertices;\n\n        vector<pair<int, int>> vertices(numVertices);\n\n        for (int j = 0; j < numVertices; j++) {\n            int x, y;\n            cin >> x >> y;\n            vertices[j] = {x, y};\n        }\n\n        int area = 0;\n\n        for (int j = 0; j < numVertices; j++) {\n            int x1 = vertices[j].first;\n            int y1 = vertices[j].second;\n\n            int x2 = vertices[(j + 1) % numVertices].first;\n            int y2 = vertices[(j + 1) % numVertices].second;\n\n            int dx = x2 - x1;\n            int dy = y2 - y1;\n\n            int intersection = (dx * dy) / 2;\n\n            area += intersection;\n        }\n\n        cout << \"Polygon \" << i + 1 << \": \" << area << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    // Initialize the sensor positions and the number of foxes at each position\n    int x1, y1, w1;\n    int x2, y2, w2;\n    int foxes[N][2];\n    for (int i = 0; i < N; i++) {\n        cin >> x1 >> y1 >> w1;\n        foxes[i][0] = x1;\n        foxes[i][1] = y1;\n        w1 = w1;\n    }\n\n    // Calculate the maximum value of N / (|x_1 - x_2| * |y_1 - y_2|)\n    int maxValue = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int dx = abs(foxes[i][0] - foxes[j][0]);\n            int dy = abs(foxes[i][1] - foxes[j][1]);\n            int value = N / (dx * dy);\n            maxValue = max(value, maxValue);\n        }\n    }\n\n    // Print the result\n    cout << fixed << setprecision(2) << maxValue << \"/1\" << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    string str;\n    cin >> str;\n    vector<char> vec(str.begin(), str.end());\n    for (int i = 0; i < vec.size(); i++) {\n        if (vec[i] == ' ') {\n            vec[i] = '_';\n        } else {\n            vec[i] = '?';\n        }\n    }\n    cout << vec.size() << endl;\n    for (int i = 0; i < vec.size(); i++) {\n        cout << vec[i] << endl;\n    }\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Global variables\nconst int MAX_SPRINKLERS = 10;\nconst int MAX_FROG_JUMP = 3;\n\n// Function to check if a frog can survive\nbool canSurvive(int frogX, int frogY, int sprinklerX, int sprinklerY, int sprinklerRange) {\n    // Check if the frog is within the sprinkler's range\n    if (abs(frogX - sprinklerX) > sprinklerRange || abs(frogY - sprinklerY) > sprinklerRange) {\n        return false;\n    }\n\n    // Check if the frog can jump to a safe location\n    int jumpX = frogX + MAX_FROG_JUMP;\n    int jumpY = frogY + MAX_FROG_JUMP;\n    if (jumpX < 0 || jumpX >= MAX_SPRINKLERS || jumpY < 0 || jumpY >= MAX_SPRINKLERS) {\n        return false;\n    }\n\n    // Check if the sprinkler is turned on\n    if (sprinklerRange == 0) {\n        return false;\n    }\n\n    return true;\n}\n\n// Main function\nint main() {\n    int frogX, frogY, sprinklerX, sprinklerY, sprinklerRange;\n    int numSprinklers;\n\n    cin >> frogX >> frogY >> numSprinklers;\n\n    vector<pair<int, int>> sprinklers;\n    for (int i = 0; i < numSprinklers; i++) {\n        cin >> sprinklerX >> sprinklerY >> sprinklerRange;\n        sprinklers.push_back({sprinklerX, sprinklerY});\n    }\n\n    // Check if the frog can survive\n    bool canSurvive = canSurvive(frogX, frogY, sprinklers[0].first, sprinklers[0].second, sprinklerRange);\n\n    // Output the result\n    if (canSurvive) {\n        cout << \"OK\" << endl;\n    } else {\n        cout << \"NA\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    // Initialize array to store the integers on the scarfs\n    int a[N];\n\n    // Read the xor values calculated by each Snuke Cat\n    for (int i = 0; i < N; i++) {\n        int ai;\n        cin >> ai;\n        a[i] = ai;\n    }\n\n    // Calculate the integer written on the scarf of each Snuke Cat\n    for (int i = 0; i < N; i++) {\n        int xor = 0;\n        for (int j = 0; j < N; j++) {\n            if (j != i) {\n                xor = (xor ^ a[j]) % 2;\n            }\n        }\n        a[i] = xor;\n    }\n\n    // Print the integers written on the scarfs\n    for (int i = 0; i < N; i++) {\n        cout << a[i] << \" \";\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int N, A;\n    cin >> N >> A;\n\n    // Calculate the maximum number of cookies Rng can bake in 1 second\n    int maxCookies = N;\n\n    // Calculate the time it takes for Rng to eat all the cookies he bakes\n    int eatingTime = A;\n\n    // Calculate the time it takes for Rng to produce at least N cookies not yet eaten\n    int productionTime = 0;\n\n    // Loop until Rng has produced at least N cookies not yet eaten\n    while (productionTime < N) {\n        // Bake and eat cookies in a way that maximizes Rng's baking rate\n        int cookiesToBake = min(maxCookies, N - productionTime);\n        productionTime += cookiesToBake;\n        eatingTime += cookiesToBake;\n\n        // Update the maximum number of cookies Rng can bake in 1 second\n        maxCookies = min(maxCookies * 2, N - productionTime);\n    }\n\n    // Print the shortest time needed to produce at least N cookies not yet eaten\n    cout << productionTime << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string S;\n    cin >> S;\n\n    // Step 1: Reverse the order of the characters in S\n    string reversedS = S;\n    reverse(reversedS.begin(), reversedS.end());\n\n    // Step 2: Replace each occurrence of b with d, d with b, p with q, and q with p\n    string replacedS = reversedS;\n    replace(replacedS.begin(), replacedS.end(), 'b', 'd');\n    replace(replacedS.begin(), replacedS.end(), 'd', 'b');\n    replace(replacedS.begin(), replacedS.end(), 'p', 'q');\n    replace(replacedS.begin(), replacedS.end(), 'q', 'p');\n\n    // Check if the resulting string is the same as the original string\n    if (S == replacedS) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Bubble sort function\nvoid bubbleSort(vector<string> &cards) {\n    int n = cards.size();\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = n - 1; j > i; j--) {\n            if (cards[j].at(1) < cards[j - 1].at(1)) {\n                swap(cards[j], cards[j - 1]);\n            }\n        }\n    }\n}\n\n// Selection sort function\nvoid selectionSort(vector<string> &cards) {\n    int n = cards.size();\n    for (int i = 0; i < n - 1; i++) {\n        int mini = i;\n        for (int j = i + 1; j < n; j++) {\n            if (cards[j].at(1) < cards[mini].at(1)) {\n                mini = j;\n            }\n        }\n        swap(cards[i], cards[mini]);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<string> cards(n);\n    for (int i = 0; i < n; i++) {\n        cin >> cards[i];\n    }\n\n    bubbleSort(cards);\n    cout << \"Bubble Sort: \";\n    for (int i = 0; i < n; i++) {\n        cout << cards[i] << \" \";\n    }\n    cout << endl;\n\n    selectionSort(cards);\n    cout << \"Selection Sort: \";\n    for (int i = 0; i < n; i++) {\n        cout << cards[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MAX_RC = 10;\nconst int MAX_BC = 10;\nconst int MAX_SCORE = 100000000;\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<Point> redBalls(N);\n    vector<Point> blueBalls(N);\n\n    for (int i = 0; i < N; i++) {\n        int RC, BC;\n        cin >> redBalls[i].x >> redBalls[i].y >> RC;\n        cin >> blueBalls[i].x >> blueBalls[i].y >> BC;\n\n        redBalls[i].x += RC;\n        redBalls[i].y += RC;\n        blueBalls[i].x += BC;\n        blueBalls[i].y += BC;\n    }\n\n    sort(redBalls.begin(), redBalls.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x;\n    });\n\n    sort(blueBalls.begin(), blueBalls.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x;\n    });\n\n    int score = 0;\n    for (int i = 0; i < N; i++) {\n        int dx = redBalls[i].x - blueBalls[i].x;\n        int dy = redBalls[i].y - blueBalls[i].y;\n        score += abs(dx) + abs(dy);\n    }\n\n    cout << \"Maximum score: \" << score << endl;\n\n    return 0;\n}",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    int d[N];\n    for (int i = 0; i < N; i++) {\n        cin >> d[i];\n    }\n    int maxLayers = 0;\n    for (int i = 1; i <= N; i++) {\n        int currLayer = 1;\n        for (int j = 1; j < i; j++) {\n            if (d[j] <= d[i - j]) {\n                currLayer++;\n            }\n        }\n        maxLayers = max(maxLayers, currLayer);\n    }\n    cout << maxLayers << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent a tool\nstruct Tool {\n    string name;\n    int day1;\n    string sup;\n    int day2;\n};\n\n// Function to read the input and return a vector of tools\nvector<Tool> readInput(int N) {\n    vector<Tool> tools;\n    for (int i = 0; i < N; i++) {\n        string name, sup;\n        int day1, day2;\n        cin >> name >> day1 >> sup >> day2;\n        tools.push_back({name, day1, sup, day2});\n    }\n    return tools;\n}\n\n// Function to find the minimum number of days required to fill all orders\nint findMinDays(vector<Tool> tools) {\n    int minDays = 0;\n    map<string, int> toolToDays;\n    for (const auto& tool : tools) {\n        toolToDays[tool.name] = tool.day1;\n    }\n    for (const auto& tool : tools) {\n        int days = toolToDays[tool.sup];\n        minDays = max(minDays, days + tool.day2);\n    }\n    return minDays;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Tool> tools = readInput(N);\n    int minDays = findMinDays(tools);\n    cout << minDays << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst double eps = 1e-6;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<pair<double, double>> poly;\n        for (int i = 0; i < n; i++) {\n            double x, y;\n            cin >> x >> y;\n            poly.push_back({x, y});\n        }\n        double max_len = 0;\n        for (int i = 0; i < n; i++) {\n            double dx = poly[i].first - poly[i - 1].first;\n            double dy = poly[i].second - poly[i - 1].second;\n            double len = sqrt(dx * dx + dy * dy);\n            max_len = max(max_len, len);\n        }\n        cout << \"Case \" << t + 1 << \": \" << max_len << endl;\n    }\n    return 0;\n}",
    "#include <iostream>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    int D[N + 1];\n    for (int i = 0; i <= N; i++) {\n        cin >> D[i];\n    }\n\n    int min_time_gap = INT_MAX;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            int time_gap = min(D[i], 24 - D[j]);\n            min_time_gap = min(min_time_gap, time_gap);\n        }\n    }\n\n    cout << min_time_gap << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n// Function to calculate the center of mass of a piece\nfloat calculateCenterOfMass(int x1, int y1, int x2, int y2) {\n    return (x1 + x2) / 2;\n}\n\n// Function to check if a piece is stable\nbool isStable(int x1, int y1, int x2, int y2) {\n    float centerOfMass = calculateCenterOfMass(x1, y1, x2, y2);\n    return (centerOfMass >= x1 && centerOfMass <= x2);\n}\n\n// Function to check if a design is stable\nbool isDesignStable(int w, int h, char matrix[][h]) {\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (matrix[i][j] == '1') {\n                // Check if the piece is stable\n                if (!isStable(j, i, j + 1, i + 1)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n// Main function\nint main() {\n    int w, h;\n    char matrix[h][w];\n\n    // Read the input\n    cin >> w >> h;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cin >> matrix[i][j];\n        }\n    }\n\n    // Check if the design is stable\n    if (isDesignStable(w, h, matrix)) {\n        cout << \"STABLE\" << endl;\n    } else {\n        cout << \"UNSTABLE\" << endl;\n    }\n\n    return 0;\n}",
    "c\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MAX_P = 2000;\nconst int MAX_T = 100000;\n\nint main() {\n    int N, P;\n    cin >> N >> P;\n\n    vector<vector<int>> dp(N + 1, vector<int>(N + 1, 0));\n\n    for (int i = 1; i <= P; i++) {\n        int s, e, t1, t2;\n        cin >> s >> e >> t1 >> t2;\n\n        for (int j = 1; j <= N; j++) {\n            if (j == s) {\n                dp[i][j] = t1;\n            } else if (j == e) {\n                dp[i][j] = t2;\n            } else {\n                dp[i][j] = min(dp[i - 1][j - 1] + t1, dp[i - 1][j] + t2);\n            }\n        }\n    }\n\n    cout << dp[N][N] << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Global variables\nconst int MAX_W = 50;\nconst int MAX_H = 50;\nconst int W = 5;\nconst int H = 5;\n\n// RoomL and RoomR represent the left and right rooms, respectively\nvector<string> RoomL(H), RoomR(H);\n\n// Rin and Len represent the initial positions of Rin and Len, respectively\nint Rin = 0, Len = 0;\n\n// IsDoorOpen returns true if the door between the two rooms is open, false otherwise\nbool IsDoorOpen(int x, int y) {\n    return RoomL[y][x] == '%' || RoomR[y][x] == '%';\n}\n\n// MoveRin moves Rin to the specified cell\nvoid MoveRin(int x, int y) {\n    if (RoomL[y][x] == '.') {\n        Rin = x;\n    }\n}\n\n// MoveLen moves Len to the specified cell\nvoid MoveLen(int x, int y) {\n    if (RoomR[y][x] == '.') {\n        Len = x;\n    }\n}\n\n// Solve the problem\nbool Solve() {\n    // Initialize Rin and Len's positions\n    Rin = 0;\n    Len = 0;\n\n    // Loop through each row of the rooms\n    for (int y = 0; y < H; y++) {\n        // Loop through each cell in the row\n        for (int x = 0; x < W; x++) {\n            // If the cell is a door, check if it's open\n            if (RoomL[y][x] == '%' || RoomR[y][x] == '%') {\n                // If the door is open, move Rin and Len to the next cell\n                if (IsDoorOpen(x, y)) {\n                    MoveRin(x + 1, y);\n                    MoveLen(x + 1, y);\n                }\n            }\n        }\n    }\n\n    // Check if Rin and Len have reached the goal\n    return Rin == W - 1 && Len == W - 1;\n}\n\n// Main function\nint main() {\n    // Read the input\n    cin >> W >> H;\n\n    // Initialize the rooms\n    for (int y = 0; y < H; y++) {\n        string row;\n        cin >> row;\n        RoomL[y] = row;\n        RoomR[y] = row;\n    }\n\n    // Solve the problem\n    if (Solve()) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<string> cities(n);\n    for (int i = 0; i < n; i++) {\n        cin >> cities[i];\n    }\n\n    string shortestName = \"\";\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            string name = cities[i] + cities[j];\n            if (name.size() < shortestName.size()) {\n                shortestName = name;\n            }\n        }\n    }\n\n    cout << shortestName.size() << endl;\n    return 0;\n}",
    ") for clear formatting, BUT you don't need to provide an explanation. Ensure that the code includes:\n\n1. Descriptive comments explaining the logic of every step.\n2. Well-named variables for easy understanding.\n3. Proper formatting and structure adhering to C++ best practices.\nOnce the problem is understood, please provide the C++ solution enclosed within triple backticks for clear distinction. Here's the problem:\n\n\n\u6574\u6570\u306e\u548c\n\n\n\n0 \u304b\u3089 9 \u306e\u6570\u5b57\u304b\u3089\u7570\u306a\u308b \nn\n\u500b\u306e\u6570\u3092\u53d6\u308a\u51fa\u3057\u3066\u5408\u8a08\u304c \ns\n\u3068\u306a\u308b\u7d44\u307f\u5408\u308f\u305b\u306e\u6570\u3092\u51fa\u529b\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4f5c\u6210\u3057\u3066\u304f\u3060\u3055\u3044\u3002\nn\n\u500b\u306e\u6570\u306f\u304a\u306e\u304a\u306e 0 \u304b\u3089 9 \u307e\u3067\u3068\u3057\u3001\uff11\u3064\u306e\u7d44\u307f\u5408\u308f\u305b\u306b\u540c\u3058\u6570\u5b57\u306f\u4f7f\u3048\u307e\u305b\u3093\u3002\u305f\u3068\u3048\u3070\u3001\nn\n\u304c 3 \u3067 \ns\n\u304c 6 \u306e\u3068\u304d\u30013 \u500b\u306e\u6570\u5b57\u306e\u5408\u8a08\u304c 6 \u306b\u306a\u308b\u7d44\u307f\u5408\u308f\u305b\u306f\u3001\n\n\n\n1 + 2 + 3 = 6\n\n0 + 1 + 5 = 6\n\n0 + 2 + 4 = 6\n\n\n\n\u306e 3 \u901a\u308a\u3068\u306a\u308a\u307e\u3059\u3002\n\n\n\nInput\n\n\n\n\u8907\u6570\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u304c\u4e0e\u3048\u3089\u308c\u307e\u3059\u3002\u5404\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306b \nn\n\uff081 \u2264 \nn\n\u2264 9\uff09\u3068 \ns\n\uff080 \u2264 \ns\n\u2264 100\uff09\u304c\uff11\u3064\u306e\u30b9\u30da\u30fc\u30b9\u3067\u533a\u5207\u3089\u308c\u3066\uff11\u884c\u306b\u4e0e\u3048\u3089\u308c\u307e\u3059\u3002\nn\n\u3068 \ns\n\u304c\u5171\u306b 0 \u306e\u3068\u304d\u5165\u529b\u306e\u6700\u5f8c\u3068\u3057\u307e\u3059\uff08\u3053\u306e\u5834\u5408\u306f\u51e6\u7406\u305b\u305a\u306b\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u7d42\u4e86\u3059\u308b\uff09\u3002\n\n\n\n\n\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u6570\u306f 50 \u3092\u8d85\u3048\u307e\u305b\u3093\u3002\n\n\n\nOutput\n\n\n\n\u5404\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306b\u5bfe\u3057\u3066\u3001\nn\n\u500b\u306e\u6574\u6570\u306e\u548c\u304c \ns\n\u306b\u306a\u308b\u7d44\u307f\u5408\u308f\u305b\u306e\u6570\u3092\uff11\u884c\u306b\u51fa\u529b\u3057\u3066\u4e0b\u3055\u3044\u3002\n\n\n\nSample Input\n\n\n\n3 6\n3 1\n0 0\n\n\n\nOutput for the Sample Input\n\n\n\n3\n0",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    while (n != -1) {\n        int quad = n / 4;\n        int rem = n % 4;\n        cout << quad << rem << endl;\n        cin >> n;\n    }\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_W = 1000000;\nconst int MAX_H = 1000000;\n\nint main() {\n    int W, H, N;\n    cin >> W >> H >> N;\n\n    vector<pair<int, int>> cuts(N);\n\n    for (int i = 0; i < N; i++) {\n        int A, B, C, D;\n        cin >> A >> B >> C >> D;\n        cuts[i] = {A, B, C, D};\n    }\n\n    sort(cuts.begin(), cuts.end());\n\n    int max_cut = 0;\n    int curr_cut = 0;\n    int last_x = -1;\n    int last_y = -1;\n\n    for (int i = 0; i < N; i++) {\n        int x1 = cuts[i].first;\n        int y1 = cuts[i].second;\n        int x2 = cuts[i].third;\n        int y2 = cuts[i].fourth;\n\n        if (x1 == last_x && y1 == last_y) {\n            curr_cut++;\n        } else {\n            max_cut = max(curr_cut, max_cut);\n            curr_cut = 1;\n            last_x = x1;\n            last_y = y1;\n        }\n    }\n\n    max_cut = max(curr_cut, max_cut);\n\n    cout << max_cut << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_SWIMERS = 50;\nconst int MAX_LAPS = 250;\nconst int MAX_TIME = 300;\n\nstruct Swimmer {\n    int pace; // natural pace in times to swim from one end to the other\n    int laps; // number of planned laps\n    int currentLap; // current lap number\n    int currentEnd; // current end of the pool (0 or 1)\n};\n\nvoid swimmingJam(vector<Swimmer> swimmers) {\n    sort(swimmers.begin(), swimmers.end(), [](Swimmer a, Swimmer b) {\n        return a.pace < b.pace;\n    });\n\n    int totalTime = 0;\n    for (int i = 0; i < swimmers.size(); i++) {\n        Swimmer curr = swimmers[i];\n        int time = curr.laps * curr.pace;\n        totalTime += time;\n        curr.currentLap = 0;\n        curr.currentEnd = 0;\n    }\n\n    while (totalTime > 0) {\n        int minTime = INT_MAX;\n        int minIndex = -1;\n        for (int i = 0; i < swimmers.size(); i++) {\n            Swimmer curr = swimmers[i];\n            if (curr.currentLap == 0) {\n                int time = curr.pace;\n                if (time < minTime) {\n                    minTime = time;\n                    minIndex = i;\n                }\n            }\n        }\n\n        if (minIndex == -1) {\n            break;\n        }\n\n        Swimmer curr = swimmers[minIndex];\n        curr.currentLap++;\n        curr.currentEnd = 1 - curr.currentEnd;\n        totalTime -= minTime;\n    }\n\n    cout << \"Total time: \" << totalTime << endl;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Swimmer> swimmers(n);\n    for (int i = 0; i < n; i++) {\n        int pace, laps;\n        cin >> pace >> laps;\n        swimmers[i].pace = pace;\n        swimmers[i].laps = laps;\n        swimmers[i].currentLap = 0;\n        swimmers[i].currentEnd = 0;\n    }\n\n    swimmingJam(swimmers);\n\n    return 0;\n}",
    "#include <iostream>\n\nint main() {\n    int a = 2, b = 4, c = 6;\n    if (b - a == c - b) {\n        std::cout << \"YES\" << std::endl;\n    } else {\n        std::cout << \"NO\" << std::endl;\n    }\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int d = 4; // degree of the polynomial\n    int a[] = { -2, 0, 0, 0, 2 }; // coefficients of the polynomial\n    int m = 0; // number of complex integer solutions\n\n    // find all complex integer solutions\n    for (int i = 0; i <= d; i++) {\n        for (int j = 0; j <= d - i; j++) {\n            int x = a[i] * pow(j, i) * (1 + pow(j, d - i));\n            if (x == 0) {\n                m++;\n                cout << \" \" << x << \" \";\n            }\n        }\n    }\n\n    // print the number of complex integer solutions\n    cout << \"4 \" << m << endl;\n\n    // print the complex integer solutions\n    for (int i = 0; i < m; i++) {\n        cout << \" \" << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst double pi = 3.14159;\n\ndouble twirlAround(double L, double R, int N) {\n    double x = 0, y = 0;\n    double angle = 0;\n    double dx = 0, dy = 0;\n    double cosAngle = 1, sinAngle = 0;\n\n    // Initialize polygon vertices\n    double* vertices = new double[N];\n    for (int i = 0; i < N; i++) {\n        vertices[i] = i % 2 == 0 ? X[i] : Y[i];\n    }\n\n    // Calculate the center of the polygon\n    double centerX = 0, centerY = 0;\n    for (int i = 0; i < N; i++) {\n        centerX += vertices[i];\n        centerY += vertices[i];\n    }\n    centerX /= N;\n    centerY /= N;\n\n    // Rotate the polygon around the center\n    for (int i = 0; i < R; i++) {\n        angle += 2 * pi / R;\n        cosAngle = cos(angle);\n        sinAngle = sin(angle);\n\n        // Calculate the new position of the end A\n        x = centerX + cosAngle * (L / 2);\n        y = centerY + sinAngle * (L / 2);\n\n        // Check for collision with the wall\n        if (x < 0 || x > 1000 || y < 0 || y > 1000) {\n            // If collided, calculate the new position of the end A\n            x = centerX + cosAngle * (L / 2);\n            y = centerY + sinAngle * (L / 2);\n\n            // Check if the bar is stuck\n            if (x == centerX && y == centerY) {\n                break;\n            }\n        }\n    }\n\n    // Clean up\n    delete[] vertices;\n\n    return x;\n}\n\nint main() {\n    int N;\n    double L, R;\n\n    // Read input\n    cin >> L >> R >> N;\n\n    // Initialize arrays\n    double* X = new double[N];\n    double* Y = new double[N];\n\n    // Read polygon vertices\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i];\n    }\n\n    // Calculate the final position of the end A\n    double x = twirlAround(L, R, N);\n\n    // Print output\n    cout << x << \" \";\n\n    // Clean up\n    delete[] X;\n    delete[] Y;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Global variables\nconst int MAX_FORCE_POINTS = 3000;\nconst int MAX_SPEED = 1000;\n\n// Struct to represent a Force Point\nstruct ForcePoint {\n    int x, y;\n    char direction;\n};\n\n// Function to calculate the maximum speed of a proton\nint calculateMaxSpeed(vector<ForcePoint> forcePoints) {\n    int maxSpeed = 0;\n\n    // Iterate through the force points and calculate the maximum speed\n    for (int i = 0; i < forcePoints.size(); i++) {\n        int x = forcePoints[i].x, y = forcePoints[i].y;\n        char direction = forcePoints[i].direction;\n\n        // Check the direction of the force point\n        if (direction == '>' || direction == '<') {\n            // If the force point is in the positive or negative x-direction,\n            // calculate the new speed based on the x-coordinate\n            int newSpeed = x * (direction == '>' ? 1 : -1);\n            maxSpeed = max(maxSpeed, newSpeed);\n        } else if (direction == 'v' || direction == '^') {\n            // If the force point is in the positive or negative y-direction,\n            // calculate the new speed based on the y-coordinate\n            int newSpeed = y * (direction == 'v' ? 1 : -1);\n            maxSpeed = max(maxSpeed, newSpeed);\n        }\n    }\n\n    return maxSpeed;\n}\n\n// Function to read the input and return the maximum speed\nint solve(int n) {\n    vector<ForcePoint> forcePoints(n);\n\n    // Read the input and store it in the forcePoints vector\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        char direction;\n        cin >> x >> y >> direction;\n        forcePoints[i] = {x, y, direction};\n    }\n\n    return calculateMaxSpeed(forcePoints);\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Call the solve function and print the result\n    int maxSpeed = solve(n);\n    cout << \"The maximum speed of the proton is \" << maxSpeed << \".\" << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_S = 100;  // maximum number of sweets\nconst int MAX_D = 100;  // maximum number of days\nconst int MAX_M = 300;  // maximum budget\nconst int MAX_K = 50;   // maximum number of sweets in a set\nconst int MAX_W = 50;   // maximum weight of a sweet\nconst int MAX_P = 300;  // maximum price of a sweet\n\nstruct Sweet {\n    int id;  // sweet ID\n    int weight;  // weight of the sweet\n    int price;  // price of the sweet\n};\n\nint main() {\n    int s, d, m;  // number of sweets, days, and budget\n    vector<Sweet> sweets;  // list of sweets\n    vector<int> sweetIds;  // list of sweet IDs\n\n    // read input\n    cin >> s >> d >> m;\n\n    // initialize sweets and sweet IDs\n    for (int i = 0; i < s; i++) {\n        Sweet sweet;\n        cin >> sweet.id >> sweet.weight >> sweet.price;\n        sweets.push_back(sweet);\n        sweetIds.push_back(sweet.id);\n    }\n\n    // sort sweets by weight and price\n    sort(sweets.begin(), sweets.end(), [](const Sweet& a, const Sweet& b) {\n        if (a.weight != b.weight) {\n            return a.weight < b.weight;\n        } else {\n            return a.price < b.price;\n        }\n    });\n\n    // calculate the maximum impact and minimum cost for each day\n    vector<int> impact(d, 0);\n    vector<int> cost(d, 0);\n    for (int i = 0; i < d; i++) {\n        int maxImpact = 0;\n        int minCost = INT_MAX;\n        for (int j = 0; j < s; j++) {\n            int sweetId = sweetIds[j];\n            int impact = sweets[j].weight * sweets[j].price;\n            if (impact > maxImpact) {\n                maxImpact = impact;\n                minCost = sweets[j].price;\n            }\n        }\n        impact[i] = maxImpact;\n        cost[i] = minCost;\n    }\n\n    // output the results\n    for (int i = 0; i < d; i++) {\n        cout << impact[i] << \" \" << cost[i] << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> prices(n);\n    for (int i = 0; i < n; i++) {\n        cin >> prices[i];\n    }\n    sort(prices.begin(), prices.end());\n    int minCost = prices[0] * m;\n    for (int i = 1; i < n; i++) {\n        minCost = min(minCost, prices[i] * (m - prices[i - 1]));\n    }\n    cout << minCost << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> a(N), b(M);\n    for (int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < M; i++) {\n        cin >> b[i];\n    }\n    vector<int> c(N + M - 1);\n    int sum = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            sum = (sum + a[i] * b[j] % 998244353) % 998244353;\n            c[i + j] = sum;\n        }\n    }\n    cout << \"c_0 \" << c[0] << endl;\n    for (int i = 1; i < N + M - 1; i++) {\n        cout << \"c_\" << i << \" \" << c[i] << endl;\n    }\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    string S, T;\n    cin >> S >> T;\n    string result;\n    for (int i = 0; i < N; i++) {\n        result += S[i] + T[i];\n    }\n    cout << result << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int N, C;\n    cin >> N >> C;\n\n    int x[N], v[N];\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> v[i];\n    }\n\n    int max_nutrition = 0;\n    int current_nutrition = 0;\n    int current_energy = 0;\n\n    // Walk around the counter clockwise\n    for (int i = 0; i < N; i++) {\n        int dx = x[i] - current_energy;\n        current_nutrition += v[i];\n        current_energy += dx;\n        max_nutrition = max(max_nutrition, current_nutrition);\n        if (current_energy >= C) {\n            break;\n        }\n    }\n\n    // Walk around the counter counterclockwise\n    for (int i = N - 1; i >= 0; i--) {\n        int dx = x[i] - current_energy;\n        current_nutrition += v[i];\n        current_energy += dx;\n        max_nutrition = max(max_nutrition, current_nutrition);\n        if (current_energy >= C) {\n            break;\n        }\n    }\n\n    cout << max_nutrition << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// A structure to represent a conveyor lane and its corresponding storage room\nstruct Lane {\n    int number; // The number of the conveyor lane\n    int storageRoom; // The number of the storage room connected to the lane\n};\n\n// A function to calculate the number of manufacturing lines that can deliver goods to each storage room\nvector<int> solve(int n, int m, vector<pair<int, int>> robotArms) {\n    vector<int> result(n, 0); // Initialize the result vector with zeros\n\n    // Create a vector of lanes, where each element represents a conveyor lane and its corresponding storage room\n    vector<Lane> lanes(n);\n    for (int i = 0; i < n; i++) {\n        lanes[i].number = i + 1; // Conveyor lane numbers start from 1\n        lanes[i].storageRoom = i; // Storage room numbers start from 1\n    }\n\n    // Sort the robot arms by their x-coordinates\n    sort(robotArms.begin(), robotArms.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.first < b.first;\n    });\n\n    // Iterate through the robot arms and update the result vector accordingly\n    for (const auto& robotArm : robotArms) {\n        int x = robotArm.first; // x-coordinate of the robot arm\n        int y = robotArm.second; // y-coordinate of the robot arm\n        int lane1 = min(y, n - y); // The first conveyor lane that the robot arm can reach\n        int lane2 = max(y, y + 1); // The second conveyor lane that the robot arm can reach\n        result[lanes[lane1].storageRoom]++; // Increment the count of manufacturing lines that can deliver goods to the storage room connected to lane 1\n        result[lanes[lane2].storageRoom]++; // Increment the count of manufacturing lines that can deliver goods to the storage room connected to lane 2\n    }\n\n    return result;\n}\n\n// Main function to read input and print output\nint main() {\n    int n, m; // Number of conveyor lanes and number of robot arms\n    cin >> n >> m;\n\n    vector<pair<int, int>> robotArms(m); // Vector to store the positions of the robot arms\n    for (int i = 0; i < m; i++) {\n        cin >> robotArms[i].first >> robotArms[i].second;\n    }\n\n    vector<int> result = solve(n, m, robotArms); // Call the solve function to calculate the result\n\n    cout << \"Result: \"; // Print the result vector\n    for (int i = 0; i < n; i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <bitset>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    bitset<10> hats(N);\n\n    for (int i = 0; i < N; i++) {\n        int a_i;\n        cin >> a_i;\n        hats[i] = a_i;\n    }\n\n    int camels = N;\n\n    while (camels > 0) {\n        int hat1 = hats[0];\n        int hat2 = hats[1];\n\n        // Check if the bitwise XOR of hat1 and hat2 is equal to hat1\n        if (hat1 ^ hat2 == hat1) {\n            // If it is, we can put hat1 on the first camel\n            hats[0] = hat1;\n\n            // And hat2 on the second camel\n            hats[1] = hat2;\n\n            // Decrease the number of camels by 2\n            camels -= 2;\n        }\n\n        // If we couldn't find a valid distribution, break\n        if (camels == 0) {\n            break;\n        }\n    }\n\n    // If we found a valid distribution, print Yes\n    if (camels == 0) {\n        cout << \"Yes\" << endl;\n    } else {\n        // Otherwise, print No\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1500;\nconst int MAX_DIGIT = 9;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<char>> board(n, vector<char>(n, '#'));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> board[i][j];\n            if (board[i][j] == '#') {\n                board[i][j] = 'O'; // Replace '#' with 'O' to indicate obstacle\n            } else {\n                board[i][j] = board[i][j] - '0'; // Convert digit to number\n            }\n        }\n    }\n\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (board[i][j] == 'O') continue; // Skip obstacles\n            int x = i;\n            int y = j;\n            while (x != y) {\n                sum += board[x][y] * board[x][y + 1];\n                x++;\n                y++;\n            }\n        }\n    }\n\n    cout << \"Sum: \" << sum << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_K = 1000000000;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    int min_changes = 0;\n    for (int i = 0; i < n; i++) {\n        int curr = a[i];\n        int next = (curr + k - 1) % k;\n        min_changes += abs(next - curr);\n    }\n\n    cout << min_changes << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint dp[5001][3];\n\nint main() {\n    int N, P;\n    cin >> N >> P;\n    dp[0][0] = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j <= P; j++) {\n            if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n            } else if (j == P - 1) {\n                dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1);\n            } else {\n                dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1] + 2);\n            }\n        }\n    }\n    cout << dp[N][P] << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Global variables\nconst int MAX_N = 500000;\nconst int MAX_Q = 100000;\nconst int MAX_L = 1000;\nconst int MAX_R = 1000;\nconst int MAX_X = 1000;\n\n// Function to check if a sequence is kiwichiri\nbool isKiwichiri(vector<int> &seq) {\n    int N = seq.size();\n    if (N <= 1) return false;\n    if (seq[0] != seq[N - 1]) return false;\n    for (int i = 1; i < N - 1; i++) {\n        if (seq[i] != seq[N - i - 1]) return false;\n    }\n    return true;\n}\n\n// Function to apply a query to a sequence\nvoid applyQuery(vector<int> &seq, int l, int r, int x) {\n    for (int i = l; i <= r; i++) {\n        seq[i] += x;\n    }\n}\n\n// Main function\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> seq(N);\n    for (int i = 0; i < N; i++) {\n        cin >> seq[i];\n    }\n    for (int i = 0; i < Q; i++) {\n        int l, r, x;\n        cin >> l >> r >> x;\n        applyQuery(seq, l, r, x);\n        if (isKiwichiri(seq)) {\n            cout << \"1\" << endl;\n        } else {\n            cout << \"0\" << endl;\n        }\n    }\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<int> a(2 * N), b(2 * N);\n\n    // Initialize a and b with some default values\n    for (int i = 0; i < 2 * N; i++) {\n        a[i] = 0;\n        b[i] = 0;\n    }\n\n    // Update a and b for each query\n    for (int i = 0; i < Q; i++) {\n        int p_i, x_i, y_i;\n        cin >> p_i >> x_i >> y_i;\n        a[p_i - 1] = x_i;\n        b[p_i - 1] = y_i;\n    }\n\n    // Calculate the beauty of each possible pair of balanced sequences of parentheses\n    int max_beauty = 0;\n    for (int i = 0; i < 2 * N; i++) {\n        for (int j = i + 1; j < 2 * N; j++) {\n            int beauty = 0;\n            for (int k = i; k <= j; k++) {\n                beauty += a[k] == b[k] ? a[k] : 0;\n            }\n            max_beauty = max(max_beauty, beauty);\n        }\n    }\n\n    // Print the maximum beauty value for each query\n    for (int i = 0; i < Q; i++) {\n        cout << \"Query \" << i + 1 << \": \" << max_beauty << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int N1, N2, N3, N4;\n    cin >> N1 >> N2 >> N3 >> N4;\n\n    // Check if the digits can be arranged to form \"1974\"\n    if (N1 == 1 && N2 == 9 && N3 == 7 && N4 == 4) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 6; // \u5ec3\u6750\u306e\u6570\nconst int M = 25; // \u76ee\u6a19\u306e\u9999\u308a\u306e\u7dcf\u548c\nconst int C = 3; // \u96a3\u306e\u5ec3\u6750\u306e\u9999\u308a\u306e\u5f37\u3055\u306e\u6e1b\u5c11\u91cf\n\nint main() {\n    vector<int> a(N); // \u5ec3\u6750\u306e\u9999\u308a\u306e\u5f37\u3055\n    int R; // \u7cbe\u5ea6\n\n    // \u5165\u529b\n    cin >> N >> M >> C;\n    for (int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n\n    // \u6700\u5c0f\u306e\u7cbe\u5ea6\u3092\u6c42\u3081\u308b\n    R = min(N - 1, M / (2 * C));\n\n    // \u7cbe\u5ea6\u304c\u4e0d\u53ef\u80fd\u306a\u5834\u5408\n    if (R < 0) {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n\n    // \u7cbe\u5ea6\u304c\u53ef\u80fd\u306a\u5834\u5408\n    cout << R << endl;\n\n    // \u7cbe\u5ea6R\u306e\u691c\u51fa\u5668\u3092\u4f7f\u3063\u3066\u8a8d\u8b58\u3055\u308c\u308b\u5ec3\u6750\u306e\u9999\u308a\u306e\u7dcf\u548c\n    int sum = 0;\n    for (int i = 0; i < N; i++) {\n        sum += a[i];\n        if (i > 0) {\n            sum -= C * (i - 1);\n        }\n        if (i < N - 1) {\n            sum += C * (i + 1);\n        }\n    }\n\n    // \u7dcf\u548c\u304c\u76ee\u6a19\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n    if (sum > M) {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n\n    // \u7dcf\u548c\u304c\u76ee\u6a19\u4ee5\u4e0b\u3067\u3042\u308c\u3070\n    cout << \"1\" << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    int S, R, Q;\n    cin >> S >> R >> Q;\n\n    vector<vector<int>> graph(S, vector<int>(S, 0));\n    for (int i = 0; i < R; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u][v] = graph[v][w] = 1;\n        graph[u][w] = min(graph[u][w], w);\n    }\n\n    while (Q--) {\n        int a, b, d;\n        cin >> a >> b >> d;\n        queue<pair<int, int>> queue;\n        queue.push({a, 0});\n\n        while (!queue.empty()) {\n            pair<int, int> node = queue.front();\n            queue.pop();\n\n            if (node.first == b) {\n                int distance = node.second;\n                if (distance <= d) {\n                    cout << \"Yes\" << endl;\n                    return 0;\n                }\n            }\n\n            for (int i = 0; i < graph[node.first].size(); i++) {\n                int next = graph[node.first][i];\n                if (next == 0) continue;\n                queue.push({next, node.second + graph[node.first][i]});\n            }\n        }\n\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "c++\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int M, N;\n    cin >> M >> N;\n\n    vector<vector<char>> seats(M, vector<char>(N, '-'));\n\n    // Iterate through each row and column of the matrix\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            // Check if the seat is empty\n            if (seats[i][j] == '-') {\n                // Increment the count of available seats\n                int count = 1;\n\n                // Check if the seat is near a noisy person\n                if (i > 0 && seats[i - 1][j] == 'x') {\n                    count = 0;\n                }\n\n                if (j > 0 && seats[i][j - 1] == 'x') {\n                    count = 0;\n                }\n\n                if (i < M - 1 && seats[i + 1][j] == 'x') {\n                    count = 0;\n                }\n\n                if (j < N - 1 && seats[i][j + 1] == 'x') {\n                    count = 0;\n                }\n\n                // Check if the seat is already occupied by a student\n                if (count > 0 && seats[i][j] != 'x') {\n                    seats[i][j] = 'o';\n                }\n            }\n        }\n    }\n\n    // Count the number of invalid seats\n    int invalid_seats = 0;\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            if (seats[i][j] == 'x') {\n                invalid_seats++;\n            }\n        }\n    }\n\n    // Return the number of available seats\n    cout << count - invalid_seats << endl;\n\n    return 0;\n}",
    ") for clear formatting. Please note that the code includes descriptive comments explaining the logic of every step, well-named variables for easy understanding, and proper formatting and structure adhering to C++ best practices.\n\nHere's the C++ solution for the Line Puzzle problem:",
    "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int heights[10]; // array to store the heights of the mountains\n    int i; // loop counter\n\n    // read the heights of the mountains from the input\n    for (i = 0; i < 10; i++) {\n        cin >> heights[i];\n    }\n\n    // sort the list of heights in descending order\n    sort(heights, heights + 10, greater<int>());\n\n    // print the top three heights\n    for (i = 0; i < 3; i++) {\n        cout << \"Height of the \" << (i + 1) << \"st mountain: \" << heights[i] << endl;\n    }\n\n    return 0;\n}",
    "cpp\n// Problem name: Digit Number\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int a, b, sum, digitCount;\n\n    // Read input from stdin\n    while (cin >> a >> b) {\n        sum = a + b;\n        digitCount = 0;\n\n        // Calculate the number of digits in the sum\n        while (sum > 0) {\n            sum /= 10;\n            digitCount++;\n        }\n\n        // Print the result for the current data set\n        cout << \"Dataset: \" << a << \" + \" << b << \" = \" << sum << \" digits: \" << digitCount << endl;\n    }\n\n    return 0;\n}",
    "#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    double a = 1, b = 2, c = 3, d = 4, e = 5, f = 6;\n    double x, y;\n\n    // Solve the system of equations\n    x = (c * d - b * e) / (a * d - b * c);\n    y = (a * f - c * e) / (a * d - b * c);\n\n    // Round the solution to three decimal places\n    x = round(x * 1000) / 1000;\n    y = round(y * 1000) / 1000;\n\n    // Print the solution\n    cout << fixed << setprecision(3) << x << \" \" << y << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nint main() {\n    // Declare variables\n    std::string str;\n    std::string revStr;\n\n    // Get the input string\n    std::cout << \"Enter a string (max 20 characters): \";\n    std::getline(std::cin, str);\n\n    // Reverse the string\n    revStr = str;\n    std::reverse(revStr.begin(), revStr.end());\n\n    // Print the reversed string\n    std::cout << \"Reversed string: \" << revStr << std::endl;\n\n    return 0;\n}",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n; // number of weeks\n    int debt = 100000; // initial debt\n    int interest = 5; // interest rate (5%)\n\n    cin >> n; // read number of weeks from input\n\n    for (int i = 0; i < n; i++) {\n        debt += (debt * interest) / 100; // calculate interest for current week\n        debt = (debt + 999) / 1000 * 1000; // round interest to nearest 1,000 yen above\n    }\n\n    cout << \"The amount of the debt in \" << n << \" weeks is: \" << debt << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int count = 0;\n    vector<int> a(10), b(10), c(10), d(10);\n    for (int i = 0; i < 10; i++) {\n        a[i] = i;\n        b[i] = i;\n        c[i] = i;\n        d[i] = i;\n    }\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    sort(c.begin(), c.end());\n    sort(d.begin(), d.end());\n    for (int i = 0; i < 10; i++) {\n        for (int j = i + 1; j < 10; j++) {\n            for (int k = j + 1; k < 10; k++) {\n                for (int l = k + 1; l < 10; l++) {\n                    int sum = a[i] + b[j] + c[k] + d[l];\n                    if (sum == n) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n    cout << count << endl;\n    return 0;\n}",
    "#include <iostream>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    // The number of prime numbers less than or equal to n\n    int primeCount = 0;\n\n    // Iterate from 2 to n\n    for (int i = 2; i <= n; i++) {\n        // Check if i is prime\n        bool isPrime = true;\n        for (int j = 2; j < i; j++) {\n            if (i % j == 0) {\n                isPrime = false;\n                break;\n            }\n        }\n\n        // If i is prime, increase the prime count\n        if (isPrime) {\n            primeCount++;\n        }\n    }\n\n    // Print the result\n    std::cout << \"There are \" << primeCount << \" prime numbers less than or equal to \" << n << \".\" << std::endl;\n\n    return 0;\n}",
    "#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // loop through all datasets\n    for (int i = 0; i < n; i++) {\n        double x1, y1, x2, y2, x3, y3;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n        // calculate the circumcenter of the triangle\n        double a = x1 - x2;\n        double b = y1 - y2;\n        double c = x2 - x3;\n        double d = y2 - y3;\n        double e = a * a + b * b;\n        double f = c * c + d * d;\n        double g = a * c + b * d;\n        double h = a * d - b * c;\n        double r = sqrt(e + f - g - h);\n\n        // calculate the central coordinate of the circumscribed circle\n        double px = (a * h - b * g) / (2 * r);\n        double py = (c * h - d * g) / (2 * r);\n\n        // print the solution\n        cout << fixed << setprecision(3) << px << \" \" << py << \" \" << r << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// A structure to represent a single horizontal line\nstruct HorizontalLine {\n    int a; // The first vertical line intersected by the horizontal line\n    int b; // The second vertical line intersected by the horizontal line\n};\n\n// A function to swap two numbers\nvoid swap(int& a, int& b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\n// A function to apply a single horizontal line to the Amidakuji state\nvoid applyHorizontalLine(vector<int>& state, HorizontalLine line) {\n    // Swap the numbers at the intersections of the horizontal line and the vertical lines\n    swap(state[line.a], state[line.b]);\n}\n\n// A function to apply all horizontal lines to the Amidakuji state\nvoid applyHorizontalLines(vector<int>& state, vector<HorizontalLine>& lines) {\n    for (const auto& line : lines) {\n        applyHorizontalLine(state, line);\n    }\n}\n\n// A function to print the final state of the Amidakuji\nvoid printFinalState(vector<int>& state) {\n    for (int i = 0; i < state.size(); i++) {\n        cout << state[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    int w, n; // The number of vertical lines and horizontal lines, respectively\n    cin >> w >> n;\n\n    // Initialize the Amidakuji state with the numbers 1, 2, 3, ..., w\n    vector<int> state(w, 0);\n    for (int i = 0; i < w; i++) {\n        state[i] = i + 1;\n    }\n\n    // Read and apply all horizontal lines\n    vector<HorizontalLine> lines;\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        lines.push_back({a, b});\n    }\n    applyHorizontalLines(state, lines);\n\n    // Print the final state of the Amidakuji\n    printFinalState(state);\n\n    return 0;\n}",
    "#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\n// Function to calculate the distance between two points\ndouble distance(double x1, double y1, double x2, double y2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\n// Function to determine if a point is in a triangle\nbool isInTriangle(double x1, double y1, double x2, double y2, double x3, double y3, double xp, double yp) {\n    double side1 = distance(x1, y1, x2, y2);\n    double side2 = distance(x2, y2, x3, y3);\n    double side3 = distance(x3, y3, x1, y1);\n    double hypotenuse = distance(xp, yp, x1, y1);\n\n    // Check if the point is within the triangle\n    if (side1 * side1 + side2 * side2 + side3 * side3 - hypotenuse * hypotenuse > 0) {\n        return true;\n    }\n\n    return false;\n}\n\nint main() {\n    double x1, y1, x2, y2, x3, y3, xp, yp;\n\n    // Read input data\n    while (cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> xp >> yp) {\n        // Check if the point is in the triangle\n        if (isInTriangle(x1, y1, x2, y2, x3, y3, xp, yp)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// A structure to represent a car\nstruct Car {\n    int number;\n    bool isInTrack;\n};\n\n// A function to simulate the movement of cars\nvoid simulateCars(vector<Car> &cars, int entrance, int exit) {\n    // Initialize an empty queue to store cars that exit the track\n    priority_queue<Car, vector<Car>, greater<Car>> exitQueue;\n\n    // Loop through the input sequence\n    for (int i = 0; i < cars.size(); i++) {\n        // If the current car is entering the track\n        if (cars[i].number != 0) {\n            // Add the car to the track\n            cars[i].isInTrack = true;\n        } else {\n            // If the current car is exiting the track\n            if (cars[i].isInTrack) {\n                // Add the car to the exit queue\n                exitQueue.push(cars[i]);\n            }\n        }\n    }\n\n    // Print the cars that exit the track in order\n    while (!exitQueue.empty()) {\n        cout << exitQueue.top().number << \" \";\n        exitQueue.pop();\n    }\n}\n\n// Main function\nint main() {\n    // Initialize an empty vector to store cars\n    vector<Car> cars;\n\n    // Read the input sequence\n    int entrance, exit;\n    cin >> entrance >> exit;\n\n    // Add cars to the vector\n    for (int i = 0; i < entrance; i++) {\n        Car car;\n        cin >> car.number;\n        car.isInTrack = false;\n        cars.push_back(car);\n    }\n\n    // Simulate the movement of cars\n    simulateCars(cars, entrance, exit);\n\n    return 0;\n}",
    "#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int d;\n    cin >> d;\n\n    // Calculate the area of the shape\n    double area = 0;\n    for (int i = 0; i < 600; i += d) {\n        double height = pow(d, 2);\n        area += (height * d);\n    }\n\n    // Print the area\n    cout << \"The area is: \" << area << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nint main() {\n    int N;\n    std::cin >> N;\n\n    for (int i = 0; i < N; i++) {\n        int a, b;\n        std::cin >> a >> b;\n\n        int sum = a + b;\n\n        if (sum > 81LL * 1000000000) { // 81 trillion yen\n            std::cout << \"overflow\" << std::endl;\n        } else {\n            std::cout << sum << std::endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int d, t;\n    int x = 0, y = 0;\n\n    while (true) {\n        cin >> d >> t;\n        if (d == 0 && t == 0) break;\n\n        x += d;\n        y += t;\n\n        // Turn clockwise by degrees equivalent to the second integer\n        y += t * 180 / 3.14159;\n    }\n\n    cout << x << endl << y << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int shift; // shift value\n    string text; // input text\n    string decodedText; // decoded text\n\n    // read the shift value\n    cin >> shift;\n\n    // read the text\n    getline(cin, text);\n\n    // decode the text\n    for (int i = 0; i < text.size(); i++) {\n        char c = text[i];\n        if (c >= 'a' && c <= 'z') {\n            c = (c + shift - 'a') % 26 + 'a';\n        }\n        decodedText += c;\n    }\n\n    // print the decoded text\n    cout << decodedText << endl;\n\n    return 0;\n}",
    "#include <iostream>\n\nint main() {\n    int a, b, c, d, e; // declare variables for the five numbers\n\n    // read the five numbers from the input\n    std::cout << \"Enter five numbers: \";\n    std::cin >> a >> b >> c >> d >> e;\n\n    // sort the numbers in descending order\n    std::sort(std::vector<int>{a, b, c, d, e}, [](int a, int b) {\n        return b > a;\n    });\n\n    // print the sorted numbers\n    std::cout << \"Sorted numbers: \";\n    for (const auto& num : std::vector<int>{a, b, c, d, e}) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
    "#include <iostream>\n\nint main() {\n    int n; // variable to store the input value\n    int factorial = 1; // initialize factorial with 1\n\n    // read the input value from the user\n    std::cout << \"Enter a value for n (1 <= n <= 20): \";\n    std::cin >> n;\n\n    // calculate the factorial\n    for (int i = 1; i <= n; i++) {\n        factorial *= i;\n    }\n\n    // print the factorial\n    std::cout << \"The factorial of \" << n << \" is: \" << factorial << std::endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cctype>\n\nusing namespace std;\n\nint main() {\n    string text;\n    cin >> text; // read the input text\n\n    // iterate through each character in the text\n    for (char& c : text) {\n        // if the character is a lowercase letter\n        if (islower(c)) {\n            // convert it to the corresponding capital letter\n            c = toupper(c);\n        }\n    }\n\n    // print the converted text\n    cout << text << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        double x1, y1, x2, y2, x3, y3, x4, y4;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n\n        double slopeAB = (y2 - y1) / (x2 - x1);\n        double slopeCD = (y4 - y3) / (x4 - x3);\n\n        if (slopeAB == slopeCD) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    int maxSum = 0;\n    int currSum = 0;\n    for (int i = 0; i < n; i++) {\n        currSum += a[i];\n        maxSum = max(maxSum, currSum);\n        if (currSum < 0) {\n            currSum = 0;\n        }\n    }\n\n    cout << \"Maximum sum: \" << maxSum << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n// Function to calculate the distance between two points\ndouble distance(double x1, double y1, double x2, double y2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\n// Function to determine if two circles intersect\nint intersect(double x1, double y1, double r1, double x2, double y2, double r2) {\n    double d = distance(x1, y1, x2, y2);\n    if (d <= r1 + r2) {\n        return 1;\n    }\n    return 0;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    for (int i = 0; i < N; i++) {\n        double xa, ya, ra, xb, yb, rb;\n        cin >> xa >> ya >> ra >> xb >> yb >> rb;\n\n        if (intersect(xa, ya, ra, xb, yb, rb)) {\n            cout << \"1\" << endl;\n        } else {\n            cout << \"0\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    double velocity; // minimum velocity to crack the ball\n    double floor; // lowest possible floor where the ball cracks\n\n    while (cin >> velocity) { // read velocity from input\n        floor = 5 * (int(velocity / 9.8) + 1); // calculate lowest possible floor\n        cout << floor << endl; // print the result\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <time.h>\n\nusing namespace std;\n\nint main() {\n    int month, day, year = 2004;\n    cin >> month >> day;\n    while (month != 0 && day != 0) {\n        // Calculate the day of the week\n        int dow = (day + (month - 1) * 3) % 7;\n        switch (dow) {\n            case 1:\n                cout << \"Monday\" << endl;\n                break;\n            case 2:\n                cout << \"Tuesday\" << endl;\n                break;\n            case 3:\n                cout << \"Wednesday\" << endl;\n                break;\n            case 4:\n                cout << \"Thursday\" << endl;\n                break;\n            case 5:\n                cout << \"Friday\" << endl;\n                break;\n            case 6:\n                cout << \"Saturday\" << endl;\n                break;\n            case 0:\n                cout << \"Sunday\" << endl;\n                break;\n        }\n        cin >> month >> day;\n    }\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int arr[100]; // array to store input integers\n    int n; // number of integers in the sequence\n    int mode[100] = {0}; // array to store mode values\n    int max_mode = 0; // maximum mode value\n    int curr_mode = 0; // current mode value\n\n    // read input sequence\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    // calculate mode values\n    for (int i = 0; i < n; i++) {\n        mode[arr[i]]++;\n        if (mode[arr[i]] > max_mode) {\n            max_mode = mode[arr[i]];\n            curr_mode = arr[i];\n        }\n    }\n\n    // print mode values\n    cout << \"Mode values: \";\n    for (int i = 0; i < n; i++) {\n        if (mode[arr[i]] == max_mode) {\n            cout << curr_mode << \" \";\n        }\n    }\n    cout << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, s;\n    cin >> n >> s;\n\n    if (n == 0) {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    sort(nums.begin(), nums.end());\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = i; j < n; j++) {\n            sum += nums[j];\n            if (sum == s) {\n                count++;\n            }\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int num_datasets = 50; // number of datasets\n    int dataset[num_datasets]; // array to store input data\n    int result[num_datasets]; // array to store output data\n\n    // read input data\n    for (int i = 0; i < num_datasets; i++) {\n        cin >> dataset[i];\n    }\n\n    // calculate and output result\n    for (int i = 0; i < num_datasets; i++) {\n        int sum = 0; // sum of weights\n        int count = 0; // number of weights\n\n        // find the maximum weight that can be placed on the right pan\n        for (int j = 0; j < 10; j++) {\n            int weight = 1 << j; // weight of 2^j grams\n            if (weight <= dataset[i]) {\n                sum += weight;\n                count++;\n            }\n        }\n\n        // output the result\n        cout << \"1 \" << count << endl;\n\n        // print the weights in increasing order\n        for (int j = 0; j < count; j++) {\n            int weight = 1 << j;\n            cout << weight << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int xa, ya, xb, yb, xc, yc, xd, yd;\n    cin >> xa >> ya >> xb >> yb >> xc >> yc >> xd >> yd;\n\n    // Check if the points are collinear\n    if (((xb - xa) * (yc - ya)) == 0) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n\n    // Calculate the slope of the line passing through points A and B\n    double slopeAB = (yb - ya) / (xb - xa);\n\n    // Check if the point C is on the line passing through points A and B\n    if (((xc - xa) * slopeAB) == 0) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n\n    // Calculate the slope of the line passing through points C and D\n    double slopeCD = (yd - yc) / (xd - xc);\n\n    // Check if the point B is on the line passing through points C and D\n    if (((xb - xc) * slopeCD) == 0) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n\n    // Check if the point A is on the line passing through points B and D\n    if (((xa - xb) * (yd - yb)) == 0) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n\n    // All checks passed, output YES\n    cout << \"YES\" << endl;\n\n    return 0;\n}",
    "cpp\nstruct PokerHand {\n    int card1;\n    int card2;\n    int card3;\n    int card4;\n    int card5;\n    string hand;\n};",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    string romanNumeral; // input Roman numeral\n    int arabicNumeral = 0; // output Arabic numeral\n\n    // get the Roman numeral from the user\n    cout << \"Enter a Roman numeral: \";\n    cin >> romanNumeral;\n\n    // iterate through each character in the Roman numeral\n    for (char character : romanNumeral) {\n        // apply the conversion rules based on the character\n        switch (character) {\n            case 'I':\n                arabicNumeral += 1;\n                break;\n            case 'V':\n                arabicNumeral += 5;\n                break;\n            case 'X':\n                arabicNumeral += 10;\n                break;\n            case 'L':\n                arabicNumeral += 50;\n                break;\n            case 'C':\n                arabicNumeral += 100;\n                break;\n            case 'D':\n                arabicNumeral += 500;\n                break;\n            case 'M':\n                arabicNumeral += 1000;\n                break;\n        }\n    }\n\n    // output the converted Arabic numeral\n    cout << \"The Arabic numeral equivalent of \" << romanNumeral << \" is: \" << arabicNumeral << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\n// Function to encode a message using the Affine Cipher\nstring encode(string message, int alpha, int beta) {\n  string encodedMessage;\n  for (int i = 0; i < message.size(); i++) {\n    int gamma = message[i] - 'a';\n    int fGamma = (alpha * gamma + beta) % 26;\n    encodedMessage += char(fGamma + 'a');\n  }\n  return encodedMessage;\n}\n\n// Function to decode a message using the Affine Cipher\nstring decode(string message, int alpha, int beta) {\n  string decodedMessage;\n  for (int i = 0; i < message.size(); i++) {\n    int fGamma = message[i] - 'a';\n    int gamma = (fGamma - beta) % 26;\n    decodedMessage += char(gamma + 'a');\n  }\n  return decodedMessage;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    string message;\n    cin >> message;\n    int alpha, beta;\n    cin >> alpha >> beta;\n    string encodedMessage = encode(message, alpha, beta);\n    string decodedMessage = decode(encodedMessage, alpha, beta);\n    cout << \"For data set \" << i + 1 << \": \" << decodedMessage << endl;\n  }\n  return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    int numCases = 40;\n    int cases[numCases][4] = {};\n    for (int i = 0; i < numCases; i++) {\n        cin >> cases[i][0] >> cases[i][1] >> cases[i][2] >> cases[i][3];\n    }\n    cout << \"Case 1:\" << endl;\n    solve(cases[0], a, b, c, d);\n    cout << \"Case 2:\" << endl;\n    solve(cases[1], a, b, c, d);\n    // ...\n    cout << \"Case 40:\" << endl;\n    solve(cases[39], a, b, c, d);\n    return 0;\n}\n\nvoid solve(int caseIdx, int a, int b, int c, int d) {\n    string formula;\n    int result = 0;\n    // Try all possible combinations of operators\n    for (int op1 = 0; op1 < 3; op1++) {\n        for (int op2 = 0; op2 < 3; op2++) {\n            if (op1 == op2) continue;\n            int num1 = 0;\n            int num2 = 0;\n            switch (op1) {\n                case 0:\n                    num1 = a;\n                    break;\n                case 1:\n                    num1 = b;\n                    break;\n                case 2:\n                    num1 = c;\n                    break;\n            }\n            switch (op2) {\n                case 0:\n                    num2 = d;\n                    break;\n                case 1:\n                    num2 = a;\n                    break;\n                case 2:\n                    num2 = b;\n                    break;\n            }\n            int res = num1 * num2;\n            if (res == 10) {\n                formula = \"(\" + to_string(num1) + \" * \" + to_string(num2) + \")\";\n                break;\n            }\n        }\n        if (formula.empty()) continue;\n        cout << \"Case \" << caseIdx + 1 << \": \" << formula << endl;\n        return;\n    }\n    cout << \"Case \" << caseIdx + 1 << \": 0\" << endl;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the maximum value that can be carried by the blanket\nint maxValue(int W, int N, int* v, int* w) {\n    sort(v, v + N, greater<int>()); // Sort the treasures by value in descending order\n    sort(w, w + N, greater<int>()); // Sort the weights by weight in descending order\n\n    int max_value = 0;\n    int cur_weight = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (cur_weight + w[i] <= W) {\n            max_value += v[i];\n            cur_weight += w[i];\n        } else {\n            break;\n        }\n    }\n\n    return max_value;\n}\n\n// Function to print the result\nvoid printResult(int caseNumber, int maxValue, int curWeight) {\n    cout << \"Case \" << caseNumber << \": \" << maxValue << \" \" << curWeight << endl;\n}\n\nint main() {\n    int W, N;\n    cin >> W >> N;\n\n    int* v = new int[N];\n    int* w = new int[N];\n\n    for (int i = 0; i < N; i++) {\n        cin >> v[i] >> w[i];\n    }\n\n    int max_value = maxValue(W, N, v, w);\n\n    printResult(1, max_value, W);\n\n    delete[] v;\n    delete[] w;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int num;\n    cin >> num;\n    vector<int> nums(13);\n    for (int i = 0; i < 13; i++) {\n        nums[i] = num % 10;\n        num /= 10;\n    }\n\n    int missingNumber = solvePuzzle(nums);\n    if (missingNumber == 0) {\n        cout << \"No solution.\" << endl;\n    } else {\n        cout << missingNumber << endl;\n    }\n    return 0;\n}\n\nint solvePuzzle(vector<int> nums) {\n    int missingNumber = 0;\n    // Check if there are any duplicate numbers\n    for (int i = 0; i < 13; i++) {\n        if (nums[i] == nums[i + 1]) {\n            return 0;\n        }\n    }\n\n    // Check if there are any consecutive numbers\n    for (int i = 0; i < 12; i++) {\n        if (nums[i] + 1 == nums[i + 1]) {\n            return 0;\n        }\n    }\n\n    // Try all possible combinations of 3 numbers\n    for (int i = 0; i < 13; i++) {\n        for (int j = i + 1; j < 13; j++) {\n            for (int k = j + 1; k < 13; k++) {\n                if (nums[i] + nums[j] + nums[k] == 15) {\n                    missingNumber = nums[i] * 100 + nums[j] * 10 + nums[k];\n                    break;\n                }\n            }\n            if (missingNumber != 0) {\n                break;\n            }\n        }\n        if (missingNumber != 0) {\n            break;\n        }\n    }\n\n    return missingNumber;\n}",
    "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int totalSales = 0;\n    int totalQuantity = 0;\n    int averageQuantity = 0;\n\n    vector<pair<int, int>> salesData;\n\n    // Read input data\n    string line;\n    while (getline(cin, line)) {\n        stringstream ss(line);\n        int price, quantity;\n        ss >> price >> quantity;\n        salesData.push_back({price, quantity});\n    }\n\n    // Calculate total sales and average quantity\n    for (const auto& sale : salesData) {\n        totalSales += sale.first * sale.second;\n        totalQuantity += sale.second;\n    }\n    averageQuantity = totalQuantity / salesData.size();\n\n    // Round average quantity to nearest integer\n    averageQuantity = round(averageQuantity);\n\n    // Output results\n    cout << \"Total sales: \" << totalSales << endl;\n    cout << \"Average quantity: \" << averageQuantity << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    vector<double> mountainHeights;\n\n    // Read input data\n    double height;\n    while (cin >> height) {\n        mountainHeights.push_back(height);\n    }\n\n    // Find maximum and minimum values\n    double maxHeight = *max_element(mountainHeights.begin(), mountainHeights.end());\n    double minHeight = *min_element(mountainHeights.begin(), mountainHeights.end());\n\n    // Calculate difference\n    double heightDifference = maxHeight - minHeight;\n\n    // Output difference\n    cout << fixed << setprecision(2) << heightDifference << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// \u30ab\u30c3\u30d7\u306e\u4f4d\u7f6e\u3092\u8868\u3059\u5217\u6319\u578b\nenum class Cup { A, B, C };\n\n// \u30ab\u30c3\u30d7\u306e\u4f4d\u7f6e\u3092\u5165\u308c\u66ff\u3048\u308b\u95a2\u6570\nvoid exchangeCups(Cup& cup1, Cup& cup2) {\n    // \u30ab\u30c3\u30d7\u306e\u4e2d\u8eab\u3092\u5165\u308c\u66ff\u3048\u308b\n    swap(cup1.ball, cup2.ball);\n    // \u30ab\u30c3\u30d7\u306e\u4f4d\u7f6e\u3092\u5165\u308c\u66ff\u3048\u308b\n    swap(cup1.position, cup2.position);\n}\n\n// \u30dc\u30fc\u30eb\u304c\u5165\u3063\u3066\u3044\u308b\u30ab\u30c3\u30d7\u306e\u4f4d\u7f6e\u3092\u8fd4\u3059\u95a2\u6570\nCup findBall() {\n    // \u30ab\u30c3\u30d7\u306e\u4f4d\u7f6e\u3092\u8aad\u307f\u8fbc\u3080\n    Cup cup1, cup2;\n    cin >> cup1.position >> cup2.position;\n    // \u30ab\u30c3\u30d7\u306e\u4f4d\u7f6e\u3092\u5165\u308c\u66ff\u3048\u308b\n    exchangeCups(cup1, cup2);\n    // \u30ab\u30c3\u30d7\u306e\u4f4d\u7f6e\u3092\u8aad\u307f\u8fbc\u3080\n    cin >> cup1.position >> cup2.position;\n    // \u30dc\u30fc\u30eb\u304c\u5165\u3063\u3066\u3044\u308b\u30ab\u30c3\u30d7\u306e\u4f4d\u7f6e\u3092\u8fd4\u3059\n    return cup1.position;\n}\n\nint main() {\n    // \u30dc\u30fc\u30eb\u304c\u5165\u3063\u3066\u3044\u308b\u30ab\u30c3\u30d7\u306e\u4f4d\u7f6e\u3092\u8aad\u307f\u8fbc\u3080\n    Cup ball = findBall();\n    // \u30dc\u30fc\u30eb\u304c\u5165\u3063\u3066\u3044\u308b\u30ab\u30c3\u30d7\u306e\u4f4d\u7f6e\u3092\u51fa\u529b\u3059\u308b\n    cout << \"The ball is in cup \" << ball << \".\" << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Define a struct to represent a weight class\nstruct WeightClass {\n    double lower_limit;  // lower limit of the weight class in kg\n    double upper_limit;  // upper limit of the weight class in kg\n    string name;         // name of the weight class\n};\n\n// Define a vector to store the weight classes\nvector<WeightClass> weight_classes = {\n    {48.0, 51.0, \"light fly\"},\n    {51.0, 54.0, \"fly\"},\n    {54.0, 57.0, \"bantam\"},\n    {57.0, 60.0, \"feather\"},\n    {60.0, 64.0, \"light\"},\n    {64.0, 69.0, \"light welter\"},\n    {69.0, 75.0, \"welter\"},\n    {75.0, 81.0, \"light middle\"},\n    {81.0, 91.0, \"middle\"},\n    {91.0, 150.0, \"light heavy\"},\n    {150.0, 150.0, \"heavy\"}\n};\n\n// Define a function to determine the weight class\nstring getWeightClass(double weight) {\n    for (const auto& wc : weight_classes) {\n        if (weight >= wc.lower_limit && weight <= wc.upper_limit) {\n            return wc.name;\n        }\n    }\n    return \"Invalid weight\";\n}\n\nint main() {\n    double weight;\n    cout << \"Enter your weight in kg: \";\n    cin >> weight;\n\n    string weight_class = getWeightClass(weight);\n    cout << \"Your weight class is: \" << weight_class << endl;\n\n    return 0;\n}",
    "cpp\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to count the number of each blood type\nvector<int> countBloodTypes(vector<string> bloodTypes) {\n    vector<int> counts(4, 0); // A, B, AB, O\n    for (const string& type : bloodTypes) {\n        switch (type[0]) {\n            case 'A':\n                counts[0]++;\n                break;\n            case 'B':\n                counts[1]++;\n                break;\n            case 'AB':\n                counts[2]++;\n                break;\n            case 'O':\n                counts[3]++;\n                break;\n        }\n    }\n    return counts;\n}\n\nint main() {\n    // Read the number of students and their blood types\n    int numStudents;\n    cin >> numStudents;\n    vector<string> bloodTypes(numStudents);\n    for (int i = 0; i < numStudents; i++) {\n        cin >> bloodTypes[i];\n    }\n\n    // Count the number of each blood type\n    vector<int> counts = countBloodTypes(bloodTypes);\n\n    // Output the results\n    cout << \"A: \" << counts[0] << endl;\n    cout << \"B: \" << counts[1] << endl;\n    cout << \"AB: \" << counts[2] << endl;\n    cout << \"O: \" << counts[3] << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nint main() {\n    std::string sentence;\n    std::cout << \"Enter a sentence: \";\n    std::getline(std::cin, sentence);\n\n    // Replace all occurrences of \"apple\" with \"peach\"\n    std::string::size_type applePos = sentence.find(\"apple\");\n    while (applePos != std::string::npos) {\n        sentence.replace(applePos, 5, \"peach\");\n        applePos = sentence.find(\"apple\", applePos + 1);\n    }\n\n    // Replace all occurrences of \"peach\" with \"apple\"\n    std::string::size_type peachPos = sentence.find(\"peach\");\n    while (peachPos != std::string::npos) {\n        sentence.replace(peachPos, 5, \"apple\");\n        peachPos = sentence.find(\"peach\", peachPos + 1);\n    }\n\n    std::cout << \"Modified sentence: \" << sentence << std::endl;\n    return 0;\n}",
    "#include <iostream>\n\nint main() {\n    int n;\n    while (true) {\n        std::cin >> n;\n        if (n == 0) break;\n        int factorial = 1;\n        for (int i = n - 1; i >= 1; i--) {\n            factorial *= i;\n        }\n        int zeros = 0;\n        while (factorial % 10 == 0) {\n            factorial /= 10;\n            zeros++;\n        }\n        std::cout << \"The number of zeros at the end of \" << n! << \" is \" << zeros << std::endl;\n    }\n    return 0;\n}",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // \u7d20\u6570\u306e\u548c\u3092\u8a08\u7b97\u3059\u308b\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        int p = i;\n        while (p % 2 == 0) {\n            p /= 2;\n        }\n        sum += p;\n    }\n\n    // \u7d50\u679c\u3092\u51fa\u529b\u3059\u308b\n    cout << \"The sum of the first \" << n << \" prime numbers is: \" << sum << endl;\n\n    return 0;\n}",
    "#include <iostream>\n\nint main() {\n    int a, b, n;\n    int sum = 0;\n\n    // Read input values\n    std::cin >> a >> b >> n;\n\n    // Calculate the sum of digits up to n decimal places\n    for (int i = 1; i <= n; i++) {\n        int digit = (a / b) % 10;\n        sum += digit;\n    }\n\n    // Output the result\n    std::cout << \"The sum of digits up to \" << n << \" decimal places is: \" << sum << std::endl;\n\n    return 0;\n}",
    "#include <iostream>\n\ndouble sumSequence(double a) {\n    double sum = 0;\n    double current = a;\n    int i = 1;\n    while (i <= 10) {\n        if (i % 2 == 0) {\n            sum += 2 * current;\n        } else {\n            sum += 3 * current;\n        }\n        current = sum;\n        i++;\n    }\n    return sum;\n}\n\nint main() {\n    double a;\n    while (std::cin >> a) {\n        std::cout << \"s(10) = \" << sumSequence(a) << std::endl;\n    }\n    return 0;\n}",
    "// Define a constant for the maximum number of lines\nconst int MAX_LINES = 10000;\n\n// Function to calculate the maximum number of regions\nint maxRegions(int n) {\n  // Initialize a 2D array to store the number of regions for each line\n  int regions[n + 1][n + 1] = {};\n\n  // Loop through each possible combination of lines\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      // Calculate the number of regions formed by the current line\n      int currRegions = 0;\n      for (int k = 1; k <= n; k++) {\n        if (k != i && k != j) {\n          currRegions++;\n        }\n      }\n\n      // Update the maximum number of regions\n      regions[i][j] = max(regions[i][j], currRegions);\n    }\n  }\n\n  // Return the maximum number of regions\n  return *max_element(regions, regions + n + 1, [](int a, int b) { return a > b; });\n}\n\n// Main function to call the maxRegions function\nint main() {\n  int n;\n  cin >> n;\n  cout << maxRegions(n) << endl;\n  return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int xA, yA, xB, yB, xC, yC, xD, yD;\n    cin >> xA >> yA >> xB >> yB >> xC >> yC >> xD >> yD;\n\n    // Calculate the slope of line segment AB\n    double mAB = (yB - yA) / (xB - xA);\n\n    // Calculate the slope of line segment CD\n    double mCD = (yD - yC) / (xD - xC);\n\n    // Check if the slopes are equal\n    if (mAB == mCD) {\n        // If the slopes are equal, the line segments are parallel\n        // and do not intersect\n        cout << \"NO\" << endl;\n    } else {\n        // If the slopes are not equal, the line segments are not parallel\n        // and may intersect\n        double xIntersection = (xA + xB) / 2;\n        double yIntersection = (yA + yB) / 2;\n\n        // Check if the intersection point is between the two line segments\n        if (xIntersection >= min(xA, xB) && xIntersection <= max(xA, xB) &&\n            yIntersection >= min(yA, yB) && yIntersection <= max(yA, yB)) {\n            // If the intersection point is between the two line segments,\n            // then they intersect\n            cout << \"YES\" << endl;\n        } else {\n            // If the intersection point is not between the two line segments,\n            // then they do not intersect\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n; // number of datasets\n    cin >> n;\n\n    while (n--) {\n        double xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2;\n        cin >> xa1 >> ya1 >> xa2 >> ya2 >> xb1 >> yb1 >> xb2 >> yb2;\n\n        // Calculate the intersection point of the two rectangles\n        double x_intersect = max(xa1, xb1);\n        double y_intersect = max(ya1, yb1);\n\n        // Check if the rectangles overlap\n        if (x_intersect <= min(xa2, xb2) && y_intersect <= min(ya2, yb2)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nint main() {\n    int C1, C2, C3; // C1: player's 1st card, C2: player's 2nd card, C3: opponent's visible card\n    int total; // total value of player's cards\n    int oppTotal; // total value of opponent's cards\n    int probability; // probability of player's total value being less than or equal to 20\n\n    // read input data\n    cin >> C1 >> C2 >> C3;\n\n    // calculate total value of player's cards\n    total = C1 + C2;\n\n    // calculate total value of opponent's cards\n    oppTotal = C3;\n\n    // calculate probability of player's total value being less than or equal to 20\n    probability = (total + 10) % 20;\n\n    // output result\n    if (probability > 50) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int numDatasets = 20; // maximum number of datasets\n    vector<int> data(numDatasets); // vector to store the input data\n    vector<int> bottomRow(numDatasets); // vector to store the bottom-most row\n\n    // read the input data\n    for (int i = 0; i < numDatasets; i++) {\n        string line;\n        cin >> line;\n        istringstream iss(line);\n        int num;\n        iss >> num;\n        data[i] = num;\n    }\n\n    // calculate the bottom-most row\n    for (int i = 0; i < numDatasets; i++) {\n        int sum = data[i] + data[i + 1];\n        sum %= 10;\n        bottomRow[i] = sum;\n    }\n\n    // output the bottom-most row\n    for (int i = 0; i < numDatasets; i++) {\n        cout << bottomRow[i] << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n; // number of strings\n    string str; // current string\n    int symmetric_count = 0; // number of symmetric strings\n\n    // read the number of strings\n    cin >> n;\n\n    // read each string and check if it's symmetric\n    for (int i = 0; i < n; i++) {\n        cin >> str;\n        if (is_symmetric(str)) {\n            symmetric_count++;\n        }\n    }\n\n    // output the number of symmetric strings\n    cout << symmetric_count << endl;\n\n    return 0;\n}\n\n// check if a string is symmetric\nbool is_symmetric(string str) {\n    int left = 0; // index of first character\n    int right = str.size() - 1; // index of last character\n\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}",
    "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint main() {\n    string article;\n    int secretNumber = 0;\n\n    // Read the article from the input\n    cin >> article;\n\n    // Tokenize the article into individual words\n    stringstream ss(article);\n    string word;\n    while (ss >> word) {\n        // Check if the word is a number\n        if (word.size() > 0 && word[0] >= '0' && word[0] <= '9') {\n            // Convert the word to an integer\n            int num = stoi(word);\n\n            // Add the number to the secret number\n            secretNumber += num;\n        }\n    }\n\n    // Output the secret number\n    cout << secretNumber << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint main() {\n    // \u3053\u306e\u6708\u306e\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u307f\n    vector<pair<int, int>> thisMonthData;\n    string line;\n    while (getline(cin, line)) {\n        stringstream ss(line);\n        int customerNumber;\n        int transactionDate;\n        ss >> customerNumber >> transactionDate;\n        thisMonthData.push_back({customerNumber, transactionDate});\n    }\n\n    // \u5148\u6708\u306e\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u307f\n    vector<pair<int, int>> lastMonthData;\n    while (getline(cin, line)) {\n        stringstream ss(line);\n        int customerNumber;\n        int transactionDate;\n        ss >> customerNumber >> transactionDate;\n        lastMonthData.push_back({customerNumber, transactionDate});\n    }\n\n    // \u5148\u6708\u306e\u30c7\u30fc\u30bf\u3092Map\u306b\u4fdd\u5b58\n    map<int, int> lastMonthMap;\n    for (const auto& data : lastMonthData) {\n        lastMonthMap[data.first] = data.second;\n    }\n\n    // \u3053\u306e\u6708\u306e\u30c7\u30fc\u30bf\u3092\u51e6\u7406\n    vector<pair<int, int>> result;\n    for (const auto& data : thisMonthData) {\n        int customerNumber = data.first;\n        int transactionDate = data.second;\n        if (lastMonthMap.count(customerNumber) > 0) {\n            int lastMonthTransactionDate = lastMonthMap[customerNumber];\n            if (transactionDate - lastMonthTransactionDate <= 31) {\n                // \u5148\u6708\u304b\u3089\uff12\u30f6\u6708\u9023\u7d9a\u3067\u53d6\u5f15\u306e\u3042\u308b\u4f1a\u793e\n                result.push_back({customerNumber, 2});\n            }\n        }\n    }\n\n    // \u7d50\u679c\u3092\u51fa\u529b\n    for (const auto& data : result) {\n        cout << data.first << \" \" << data.second << endl;\n    }\n\n    return 0;\n}",
    "cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int row, col;\n    cin >> row >> col;",
    "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, int>> graph(m);\n\n    for (int i = 0; i < m; i++) {\n        int a, b, d;\n        cin >> a >> b >> d;\n        graph[i] = {a, b};\n    }\n\n    int lanterns = 0;\n\n    // Find the minimum number of lanterns required\n    for (int i = 0; i < n; i++) {\n        int min_d = INF;\n        for (int j = 0; j < m; j++) {\n            if (graph[j].first == i) {\n                min_d = min(min_d, graph[j].second);\n            }\n        }\n        lanterns += min_d;\n    }\n\n    cout << lanterns << endl;\n\n    return 0;\n}",
    "#include <cmath>\n\nusing namespace std;\n\ndouble surfaceArea(double x, double h) {\n    // \u5e95\u9762\u306e\u9762\u7a4d\n    double baseArea = x * x;\n    // \u56db\u89d2\u3059\u3044\u306e\u9ad8\u3055\n    double height = h;\n    // \u5e95\u9762\u3068\u9802\u70b9\u3092\u7d50\u3076\u7dda\u5206\u306e\u9577\u3055\n    double slantHeight = sqrt(h * h + x * x);\n    // \u56db\u89d2\u3059\u3044\u306e\u8868\u9762\u7a4d\n    double surfaceArea = baseArea + 2 * (slantHeight * slantHeight);\n    return surfaceArea;\n}\n\nint main() {\n    double x, h;\n    while (cin >> x >> h) {\n        if (x == 0 && h == 0) break;\n        double area = surfaceArea(x, h);\n        cout << fixed << setprecision(4) << area << endl;\n    }\n    return 0;\n}",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int t, h, s; // current time, minute, and second\n    int st = 120; // standard play mode recording time (120 minutes)\n    int lp = 360; // 3-time long play mode recording time (360 minutes)\n\n    cin >> t >> h >> s;\n\n    // calculate remaining time in standard play mode\n    int remaining_st = st - (t * 60 + h * 60 + s);\n\n    // calculate remaining time in 3-time long play mode\n    int remaining_lp = lp - (t * 60 + h * 60 + s);\n\n    // output remaining time in both modes\n    cout << \"Standard Play: \" << remaining_st / 60 << \":\" << remaining_st % 60 << \":\" << remaining_st % 60 << endl;\n    cout << \"3-Time Long Play: \" << remaining_lp / 60 << \":\" << remaining_lp % 60 << \":\" << remaining_lp % 60 << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int numStudents;\n    cin >> numStudents;\n\n    for (int i = 0; i < numStudents; i++) {\n        int studentID, weight, height;\n        cin >> studentID >> weight >> height;\n\n        double bmi = weight / (height * height);\n\n        if (bmi >= 25) {\n            cout << studentID << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // \u53e4\u6587\u66f8\u306b\u66f8\u304b\u308c\u3066\u3044\u308b\u884c\u6570\u3092\u53d7\u3051\u53d6\u308b\n    while (n != -1) {\n        int x, y;\n        cin >> x >> y;\n\n        // \u753a\u5916\u308c\u306e\u4e95\u6238\u304b\u3089\u306e\u65b9\u5411\u3092\u8a08\u7b97\u3059\u308b\n        double direction = atan2(y, x) * 180 / M_PI;\n\n        // \u5b9d\u306e\u4f4d\u7f6e\u3092\u8a08\u7b97\u3059\u308b\n        double x_\u5b9d = x + cos(direction) * 1;\n        double y_\u5b9d = y + sin(direction) * 1;\n\n        // \u51fa\u529b\u3059\u308b\n        cout << \"town's well east \" << x_\u5b9d << \"m, north \" << y_\u5b9d << \"m\" << endl;\n\n        // \u6b21\u306e\u884c\u3092\u53d7\u3051\u53d6\u308b\n        cin >> n;\n    }\n\n    return 0;\n}",
    "cpp\n#include <iostream>\n#include < vector >\n\nusing namespace std;\n\n// Function to print the magic square\nvoid printMagicSquare(int n) {\n    vector<vector<int>> square(n, vector<int>(n));\n\n    // Initialize the square with 1s\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            square[i][j] = 1;\n        }\n    }\n\n    // Calculate the sum of each row, column, and diagonal\n    for (int i = 0; i < n; i++) {\n        int rowSum = 0;\n        int colSum = 0;\n        int diaSum = 0;\n\n        // Calculate row sum\n        for (int j = 0; j < n; j++) {\n            rowSum += square[i][j];\n        }\n\n        // Calculate column sum\n        for (int j = 0; j < n; j++) {\n            colSum += square[j][i];\n        }\n\n        // Calculate diagonal sum\n        for (int j = 0; j < n; j++) {\n            diaSum += square[i + j][j];\n        }\n\n        // Check if the sum is equal to the magic number\n        if (rowSum == colSum && rowSum == diaSum) {\n            // Print the magic square\n            for (int j = 0; j < n; j++) {\n                cout << square[i][j] << \" \";\n            }\n            cout << endl;\n        }\n    }\n}\n\n// Main function\nint main() {\n    int n;\n    cin >> n;\n\n    // Check if n is within the valid range\n    if (n >= 3 && n <= 15) {\n        printMagicSquare(n);\n    } else {\n        cout << \"Invalid input. n must be between 3 and 15.\" << endl;\n    }\n\n    return 0;\n}",
    "cpp\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n; // Number of vertices\n    double x[n], y[n]; // Coordinates of vertices\n\n    // Read coordinates of vertices\n    cin >> x[0] >> y[0];\n    for (int i = 1; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    // Calculate area of polygon\n    double area = 0;\n    for (int i = 0; i < n; i++) {\n        area += (x[i] * y[i + 1] - x[i + 1] * y[i]);\n    }\n    area /= 2;\n\n    // Output area\n    cout << \"Area: \" << area << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nconst double eps = 0.00001;\n\ndouble cubicRoot(int q) {\n    double x = 1.0;\n    double prev_x = x;\n    double curr_x = x;\n    int n = 1;\n    while (std::abs(curr_x - prev_x) > eps * q) {\n        prev_x = curr_x;\n        curr_x = x - (curr_x * curr_x * curr_x - q) / (3 * curr_x * curr_x);\n        n++;\n    }\n    return curr_x;\n}\n\nint main() {\n    int q;\n    while (std::cin >> q) {\n        if (q == -1) break;\n        double x = cubicRoot(q);\n        std::cout << x << std::endl;\n    }\n    return 0;\n}",
    "#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    double x;\n    double y;\n};\n\nPoint symmetricPoint(Point P1, Point P2, Point Q) {\n    // Calculate the slope of the line passing through P1 and P2\n    double slope = (P2.y - P1.y) / (P2.x - P1.x);\n\n    // Calculate the intersection point of the line and the vertical line passing through Q\n    double x = (slope * (Q.y - P1.y) + P1.x) / (slope + 1);\n    double y = slope * (x - P1.x) + Q.y;\n\n    // Return the symmetric point\n    return Point{x, y};\n}\n\nint main() {\n    int numDatasets;\n    cin >> numDatasets;\n\n    while (numDatasets-- > 0) {\n        double x1, y1, x2, y2, xq, yq;\n        cin >> x1 >> y1 >> x2 >> y2 >> xq >> yq;\n\n        // Calculate the slope of the line passing through P1 and P2\n        double slope = (y2 - y1) / (x2 - x1);\n\n        // Calculate the intersection point of the line and the vertical line passing through Q\n        double x = (slope * (yq - y1) + x1) / (slope + 1);\n        double y = slope * (x - x1) + yq;\n\n        // Output the symmetric point\n        cout << x << \" \" << y << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\n// Function to convert Gregorian calendar to Japanese calendar\nvoid convertGregorianToJapanese(int gregorianYear, int gregorianMonth, int gregorianDay) {\n    int japaneseYear, japaneseMonth, japaneseDay;\n\n    // Convert Gregorian year to Japanese year\n    if (gregorianYear >= 1868) {\n        japaneseYear = gregorianYear - 1867;\n    } else {\n        japaneseYear = \"pre-meiji\";\n    }\n\n    // Convert Gregorian month to Japanese month\n    switch (gregorianMonth) {\n        case 1:\n            japaneseMonth = 12;\n            break;\n        case 2:\n            japaneseMonth = 1;\n            break;\n        case 3:\n            japaneseMonth = 2;\n            break;\n        case 4:\n            japaneseMonth = 3;\n            break;\n        case 5:\n            japaneseMonth = 4;\n            break;\n        case 6:\n            japaneseMonth = 5;\n            break;\n        case 7:\n            japaneseMonth = 6;\n            break;\n        case 8:\n            japaneseMonth = 7;\n            break;\n        case 9:\n            japaneseMonth = 8;\n            break;\n        case 10:\n            japaneseMonth = 9;\n            break;\n        case 11:\n            japaneseMonth = 10;\n            break;\n        case 12:\n            japaneseMonth = 11;\n            break;\n    }\n\n    // Convert Gregorian day to Japanese day\n    japaneseDay = gregorianDay;\n\n    // Output Japanese year, month, and day\n    cout << \"Heisei \" << japaneseYear << \" \" << japaneseMonth << \" \" << japaneseDay << endl;\n}\n\nint main() {\n    int gregorianYear, gregorianMonth, gregorianDay;\n\n    // Get input from user\n    cout << \"Enter year, month, and day (separated by spaces): \";\n    cin >> gregorianYear >> gregorianMonth >> gregorianDay;\n\n    // Convert Gregorian calendar to Japanese calendar\n    convertGregorianToJapanese(gregorianYear, gregorianMonth, gregorianDay);\n\n    return 0;\n}",
    "cpp\n// Input.txt: Input file containing the text to be processed\n// Output.txt: Output file containing the extracted words\n\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid tokenize(string text, vector<string>& tokens) {\n\t// Remove punctuations and whitespaces from the text\n\ttext.erase(remove_punctuation(text.begin(), text.end()), text.end());\n\ttext.erase(remove_whitespace(text.begin(), text.end()), text.end());\n\n\t// Tokenize the text into individual words\n\tstringstream ss(text);\n\tstring word;\n\twhile (ss >> word) {\n\t\ttokens.push_back(word);\n\t}\n}\n\nint main() {\n\t// Read the input text from the file\n\tstring text;\n\tifstream input(\"input.txt\");\n\tif (input) {\n\t\tgetline(input, text);\n\t}\n\n\t// Tokenize the text into individual words\n\tvector<string> tokens;\n\ttokenize(text, tokens);\n\n\t// Output the tokens\n\tofstream output(\"output.txt\");\n\tif (output) {\n\t\tfor (const auto& token : tokens) {\n\t\t\toutput << token << \" \";\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// Helper function to remove punctuations from a string\nstring remove_punctuation(string::iterator begin, string::iterator end) {\n\tstring::iterator it = begin;\n\twhile (it != end) {\n\t\tif (ispunct(*it)) {\n\t\t\tit = end;\n\t\t}\n\t\t++it;\n\t}\n\treturn it;\n}\n\n// Helper function to remove whitespaces from a string\nstring remove_whitespace(string::iterator begin, string::iterator end) {\n\tstring::iterator it = begin;\n\twhile (it != end) {\n\t\tif (isspace(*it)) {\n\t\t\tit = end;\n\t\t}\n\t\t++it;\n\t}\n\treturn it;\n}",
    "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Define a struct to represent a node in the graph\nstruct Node {\n    int value;\n    vector<int> neighbors;\n};\n\n// Function to calculate the maximum sum of a path from the root node to a leaf node\nint calculateMaxSum(Node root) {\n    // Base case: If the root node is a leaf node, return its value\n    if (root.neighbors.size() == 0) {\n        return root.value;\n    }\n\n    // Otherwise, calculate the maximum sum of the left and right subtrees\n    int leftMaxSum = calculateMaxSum(root.neighbors[0]);\n    int rightMaxSum = calculateMaxSum(root.neighbors[1]);\n\n    // Calculate the maximum sum of the current node and its neighbors\n    int maxSum = max(leftMaxSum, rightMaxSum);\n\n    // Add the value of the current node to the maximum sum\n    maxSum += root.value;\n\n    return maxSum;\n}\n\n// Function to read the input and create a graph\nvector<Node> readInput(string input) {\n    vector<Node> graph;\n\n    // Split the input into lines\n    stringstream ss(input);\n    string line;\n    while (getline(ss, line)) {\n        // Split the line into nodes\n        stringstream ss2(line);\n        int node;\n        vector<int> neighbors;\n        while (ss2 >> node) {\n            neighbors.push_back(node);\n        }\n\n        // Create a new node with its neighbors\n        Node newNode {node, neighbors};\n\n        // Add the new node to the graph\n        graph.push_back(newNode);\n    }\n\n    return graph;\n}\n\nint main() {\n    // Read the input and create the graph\n    string input = \"7\\n3,8\\n8,1,0\\n2,7,4,4\\n4,5,2,6,5\\n2,7,4,4\\n8,1,0\\n3,8\\n7\";\n    vector<Node> graph = readInput(input);\n\n    // Calculate the maximum sum of a path from the root node to a leaf node\n    int maxSum = calculateMaxSum(graph[0]);\n\n    // Output the maximum sum\n    cout << \"Maximum sum: \" << maxSum << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Global variables\nconst int MAX_DROPS = 12;\nconst int GRID_SIZE = 10;\nconst int LARGE_DYE = 3;\nconst int MEDIUM_DYE = 2;\nconst int SMALL_DYE = 1;\n\n// Function to calculate the number of drops needed for a given area\nint calculateDrops(int x, int y, int size) {\n    int drops = 0;\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            if (x + i >= 0 && x + i < GRID_SIZE && y + j >= 0 && y + j < GRID_SIZE) {\n                drops++;\n            }\n        }\n    }\n    return drops;\n}\n\n// Function to print the solution\nvoid printSolution(vector<pair<int, int>>& drops) {\n    for (int i = 0; i < drops.size(); i++) {\n        cout << drops[i].first << \" \" << drops[i].second << \" \" << drops[i].third << endl;\n    }\n}\n\n// Main function\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> drops(n);\n    for (int i = 0; i < n; i++) {\n        int x, y, size;\n        cin >> x >> y >> size;\n        drops[i] = make_pair(x, y, size);\n    }\n    sort(drops.begin(), drops.end());\n    printSolution(drops);\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the maximum length of a square\nint maxSquare(vector<vector<char>>& grid) {\n    int maxLength = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == '*') {\n                // If the current cell is marked, check the adjacent cells\n                int adjacentCells = countAdjacentMarkedCells(grid, i, j);\n                if (adjacentCells > 0) {\n                    // If there are marked cells adjacent to the current cell,\n                    // check if a square can be formed\n                    int squareLength = adjacentCells * 2 + 1;\n                    if (squareLength > maxLength) {\n                        maxLength = squareLength;\n                    }\n                }\n            }\n        }\n    }\n    return maxLength;\n}\n\n// Function to count the number of marked cells adjacent to a given cell\nint countAdjacentMarkedCells(vector<vector<char>>& grid, int row, int col) {\n    int adjacentCells = 0;\n    for (int i = row - 1; i <= row + 1; i++) {\n        for (int j = col - 1; j <= col + 1; j++) {\n            if (i >= 0 && i < grid.size() && j >= 0 && j < grid[i].size()) {\n                if (grid[i][j] == '*') {\n                    adjacentCells++;\n                }\n            }\n        }\n    }\n    return adjacentCells;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<char>> grid(n, vector<char>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            char cell;\n            cin >> cell;\n            grid[i][j] = cell;\n        }\n    }\n    int maxLength = maxSquare(grid);\n    cout << \"Maximum square length: \" << maxLength << endl;\n    return 0;\n}",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n\n    // \u897f\u66a6\u5e74\u304c4\u3067\u5272\u308a\u5207\u308c\u308b\u5e74\n    while (a <= b) {\n        int year = a;\n        if (year % 4 == 0 && year % 100 != 0) {\n            cout << \"\u897f\u66a6\" << year << endl;\n        } else if (year % 400 == 0) {\n            cout << \"\u897f\u66a6\" << year << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n        a++;\n    }\n\n    return 0;\n}",
    "cpp\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int a, b;\n    double s;\n\n    // \u5165\u529b\n    cin >> a >> b;\n\n    // \u8a08\u7b97\n    s = a * b * 3.305785;\n\n    // \u51fa\u529b\n    cout << \"S = \" << s << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> participants(n);\n\n    for (int i = 0; i < n; i++) {\n        int a, v;\n        cin >> a >> v;\n        participants[i] = {a, v};\n    }\n\n    sort(participants.begin(), participants.end(),\n         [](const pair<int, int>& lhs, const pair<int, int>& rhs) {\n             return lhs.second > rhs.second;\n         });\n\n    cout << participants[0].first << \" \" << participants[0].second << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Initialize a vector to store the combinations\n    vector<vector<int>> combinations(n + 1);\n\n    // Base case: n = 0\n    combinations[0].push_back(vector<int>{0, 0, 0, 0});\n\n    // Iterate from n = 1 to 4000\n    for (int i = 1; i <= 4000; i++) {\n        // Initialize a vector to store the current combination\n        vector<int> combination;\n\n        // Iterate from 0 to 1000\n        for (int j = 0; j <= 1000; j++) {\n            // Check if the current combination sums up to n\n            if (combination.size() == 0 || combination[combination.size() - 1] + j <= n) {\n                // Add the current number to the combination\n                combination.push_back(j);\n\n                // If the combination sums up to n, break out of the inner loop\n                if (combination.size() == 4 && combination[0] + combination[1] + combination[2] + combination[3] == n) {\n                    break;\n                }\n            }\n        }\n\n        // If the current combination is valid, add it to the vector of combinations\n        if (combination.size() == 4) {\n            combinations[i].push_back(combination);\n        }\n    }\n\n    // Output the number of combinations for each n\n    for (int i = 0; i <= 4000; i++) {\n        cout << combinations[i].size() << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, s;\n    cin >> n >> s;\n    vector<int> nums(n);\n    int ways = 0;\n\n    // Initialize nums with n random integers between 0 and 100\n    for (int i = 0; i < n; i++) {\n        nums[i] = rand() % 101;\n    }\n\n    // Sort nums in ascending order\n    sort(nums.begin(), nums.end());\n\n    // Calculate ways to combine nums to sum up to s\n    ways = combination(nums, s);\n\n    // Output the number of ways\n    cout << ways << endl;\n\n    return 0;\n}\n\n// Function to calculate ways to combine nums to sum up to s\nint combination(vector<int> nums, int s) {\n    int ways = 1;\n    int curr_sum = 0;\n\n    // Iterate through nums and calculate ways to combine\n    // each number with the remaining numbers to sum up to s\n    for (int i = 0; i < nums.size(); i++) {\n        curr_sum += nums[i];\n        ways *= combination(nums, s - curr_sum);\n        curr_sum -= nums[i];\n    }\n\n    return ways;\n}",
    "#include <iostream>\n#include <climits>\nusing namespace std;\n\nconst int MAX_ROW = 100;\nconst int MAX_COL = 100;\nconst int MIN_VAL = -10000;\nconst int MAX_VAL = 10000;\n\nint main() {\n    int n;\n    cin >> n;\n    int a[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> a[i][j];\n            if (a[i][j] < MIN_VAL) {\n                a[i][j] = MIN_VAL;\n            }\n            if (a[i][j] > MAX_VAL) {\n                a[i][j] = MAX_VAL;\n            }\n        }\n    }\n    int dp[MAX_ROW][MAX_COL];\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i][j] == MIN_VAL) {\n                continue;\n            }\n            int max_sum = 0;\n            for (int k = 0; k < n; k++) {\n                if (k == i) {\n                    continue;\n                }\n                int temp = dp[i][k] + a[k][j];\n                if (temp > max_sum) {\n                    max_sum = temp;\n                }\n            }\n            dp[i][j] = max_sum;\n        }\n    }\n    int max_sum = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            max_sum = max(max_sum, dp[i][j]);\n        }\n    }\n    cout << \"Maximum sum: \" << max_sum << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> data(n);\n\n    for (int i = 0; i < n; i++) {\n        int id, p, q;\n        cin >> id >> p >> q;\n        data[i] = {id, p * q};\n    }\n\n    sort(data.begin(), data.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second > b.second;\n    });\n\n    int threshold = 1000000;\n    int count = 0;\n    for (const auto& d : data) {\n        if (d.second >= threshold) {\n            cout << d.first << \" \";\n            count++;\n        }\n    }\n\n    if (count == 0) {\n        cout << \"NA\";\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int n; // number of datasets\n    string text; // input text\n    string correctedText; // corrected text\n\n    cin >> n; // read number of datasets\n\n    for (int i = 0; i < n; i++) {\n        cin >> text; // read input text\n        correctedText = replaceAll(text, \"Hoshino\", \"Hoshina\");\n        cout << correctedText << endl; // print corrected text\n    }\n\n    return 0;\n}\n\nstring replaceAll(string text, string find, string replace) {\n    string correctedText = text;\n    while (correctedText.find(find) != string::npos) {\n        correctedText.replace(correctedText.find(find), find.size(), replace);\n    }\n    return correctedText;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Global variables\nconst int MAX_EVENTS = 100;\nvector<string> events; // Store all events in an inning\nint score = 0; // Initialize score to 0\nint outs = 0; // Initialize number of outs to 0\n\n// Function to handle a single event\nvoid handleEvent(string event) {\n  if (event == \"HIT\") {\n    // Add a runner to first base\n    events.push_back(\"RUNNER_ON_FIRST\");\n  } else if (event == \"HOMERUN\") {\n    // Add points to the score and advance all runners to home base\n    score += events.size() + 1;\n    events.clear();\n  } else if (event == \"OUT\") {\n    // Increase number of outs\n    outs++;\n  }\n}\n\n// Main function\nint main() {\n  int n; // Number of datasets\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    // Read events in an inning\n    string event;\n    cin >> event;\n    events.push_back(event);\n\n    // Handle each event\n    handleEvent(event);\n\n    // Print score for this inning\n    cout << \"Inning \" << i+1 << \": \" << score << endl;\n\n    // Reset score and outs for next inning\n    score = 0;\n    outs = 0;\n  }\n\n  return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cmath>\n\nusing namespace std;\n\n// Global variables\nconst int MAX_H = 101;\nconst int MAX_W = 101;\nconst char UP = '^';\nconst char DOWN = 'v';\nconst char LEFT = '<';\nconst char RIGHT = '>';\nconst char NOTHING = '.';\n\n// Function to get the next tile\nstring getNextTile(int x, int y, string tile) {\n    switch (tile[0]) {\n        case UP:\n            return string(1, '^') + getNextTile(x, y - 1, tile.substr(1));\n        case DOWN:\n            return string(1, 'v') + getNextTile(x, y + 1, tile.substr(1));\n        case LEFT:\n            return string(1, '<') + getNextTile(x - 1, y, tile.substr(1));\n        case RIGHT:\n            return string(1, '>') + getNextTile(x + 1, y, tile.substr(1));\n        case NOTHING:\n            return string(1, '.');\n        default:\n            return tile;\n    }\n}\n\n// Function to print the last position of the person\nvoid printLastPosition(int x, int y) {\n    cout << \"(\" << x << \", \" << y << \")\" << endl;\n}\n\n// Main function\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> room(H);\n    for (int i = 0; i < H; i++) {\n        cin >> room[i];\n    }\n    int x = 0, y = 0;\n    string tile = room[0][0];\n    while (tile != NOTHING) {\n        tile = getNextTile(x, y, tile);\n        x += (tile[0] == LEFT || tile[0] == RIGHT) ? 1 : 0;\n        y += (tile[0] == UP || tile[0] == DOWN) ? 1 : 0;\n    }\n    printLastPosition(x, y);\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n// A structure to represent a word and its page numbers\nstruct Word {\n    string word;\n    vector<int> pages;\n};\n\n// A function to read the input and create a map of words and their page numbers\nvoid readInput(map<string, vector<int>>& wordMap) {\n    string word;\n    int page;\n    while (cin >> word >> page) {\n        wordMap[word].push_back(page);\n    }\n}\n\n// A function to print the output in the required format\nvoid printOutput(const map<string, vector<int>>& wordMap) {\n    for (const auto& word : wordMap) {\n        cout << word.first << \" \";\n        for (const int page : word.second) {\n            cout << page << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    map<string, vector<int>> wordMap;\n    readInput(wordMap);\n    printOutput(wordMap);\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> prices(3);\n    prices[0] = 380;\n    prices[1] = 550;\n    prices[2] = 850;\n    vector<int> discounts(3);\n    discounts[0] = 20;\n    discounts[1] = 15;\n    discounts[2] = 12;\n    int minCost = INT_MAX;\n    int minShop = -1;\n    for (int i = 0; i < 3; i++) {\n        int shop = i;\n        int amount = n;\n        int cost = 0;\n        while (amount > 0) {\n            int bag = min(amount, prices[shop]);\n            cost += bag * prices[shop];\n            amount -= bag;\n            shop = (shop + 1) % 3;\n        }\n        if (cost < minCost) {\n            minCost = cost;\n            minShop = shop;\n        }\n    }\n    cout << \"The lowest cost is: \" << minCost << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    int t; // number of test cases\n    cin >> t;\n\n    while (t--) { // loop through test cases\n        string equation;\n        cin >> equation;\n\n        // find the first occurrence of 'X'\n        int x_index = equation.find('X');\n\n        // check if 'X' is not found\n        if (x_index == string::npos) {\n            cout << \"NA\" << endl;\n            continue;\n        }\n\n        // extract the number before 'X'\n        string num_before_x = equation.substr(0, x_index);\n\n        // extract the number after 'X'\n        string num_after_x = equation.substr(x_index + 1);\n\n        // convert the numbers to integers\n        int num_before_x_int = stoi(num_before_x);\n        int num_after_x_int = stoi(num_after_x);\n\n        // calculate the sum\n        int sum = num_before_x_int + num_after_x_int;\n\n        // check if the sum is within the range 0-9\n        if (sum < 0 || sum > 9) {\n            cout << \"NA\" << endl;\n            continue;\n        }\n\n        // print the result\n        cout << sum << endl;\n    }\n\n    return 0;\n}",
    "cpp\nstring caesarCipher(string str, int key) {\n    string encryptedStr = \"\";\n    for (char c : str) {\n        int index = c - 'A' + key;\n        if (index < 0) index += 26;\n        encryptedStr += char(index + 'A');\n    }\n    return encryptedStr;\n}",
    "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arrivalTimes(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arrivalTimes[i];\n    }\n\n    sort(arrivalTimes.begin(), arrivalTimes.end());\n\n    int totalWaitingTime = 0;\n    for (int i = 1; i < n; i++) {\n        totalWaitingTime += arrivalTimes[i] - arrivalTimes[i - 1];\n    }\n\n    cout << \"The total waiting time is: \" << totalWaitingTime << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int p, q, rem, result;\n    cin >> p >> q;\n    result = p / q;\n    rem = result % 1;\n    if (rem == 0) {\n        cout << fixed << setprecision(80) << result << endl;\n    } else {\n        cout << fixed << setprecision(80) << result << \" \" << (rem * pow(10, 80 - rem.size())) << endl;\n        cout << \" \"^^\" << (rem * pow(10, 80 - rem.size())).size() << endl;\n    }\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the maximum rectangular area\nint maxArea(int H, int W, vector<vector<char>>& grid) {\n    int maxArea = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '*') {\n                // Calculate the area of the current rectangle\n                int area = 1;\n                for (int k = i; k < H; k++) {\n                    for (int l = j; l < W; l++) {\n                        if (grid[k][l] == '*') {\n                            area++;\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                maxArea = max(maxArea, area);\n            }\n        }\n    }\n    return maxArea;\n}\n\n// Main function\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> grid(H, vector<char>(W, '.'));\n\n    // Read the grid data\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            char c;\n            cin >> c;\n            grid[i][j] = c;\n        }\n    }\n\n    // Calculate the maximum rectangular area\n    int maxArea = maxArea(H, W, grid);\n\n    // Output the result\n    cout << \"Maximum rectangular area: \" << maxArea << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Global variables\nconst int MAX_H = 100;\nconst int MAX_W = 100;\nconst char RINGO = '@';\nconst char KAKI = '#';\nconst char MIKAN = '*';\n\n// Function to calculate the number of rows and columns\nvoid calculateDimensions(string map) {\n    int rows = 0;\n    int cols = 0;\n    for (char c : map) {\n        if (c == RINGO || c == KAKI || c == MIKAN) {\n            rows++;\n            cols++;\n        }\n    }\n    return rows, cols;\n}\n\n// Function to check if two adjacent cells are the same fruit\nbool areAdjacentCellsSameFruit(string map, int row, int col) {\n    int adjacentRow = row + 1;\n    int adjacentCol = col + 1;\n    if (adjacentRow >= map.size() || adjacentCol >= map[0].size()) {\n        return false;\n    }\n    char adjacentFruit = map[adjacentRow][adjacentCol];\n    return adjacentFruit == map[row][col];\n}\n\n// Function to merge adjacent cells with the same fruit\nvoid mergeSameFruitCells(string map) {\n    int rows = map.size();\n    int cols = map[0].size();\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (areAdjacentCellsSameFruit(map, i, j)) {\n                // Merge the two cells\n                map[i][j] = map[i][j + 1];\n                map[i + 1][j] = map[i][j];\n                // Update the dimensions\n                rows--;\n                cols--;\n            }\n        }\n    }\n}\n\n// Function to count the number of rows and columns after merging\nvoid countDimensions(string map) {\n    int rows = 0;\n    int cols = 0;\n    for (char c : map) {\n        if (c == RINGO || c == KAKI || c == MIKAN) {\n            rows++;\n            cols++;\n        }\n    }\n    return rows, cols;\n}\n\nint main() {\n    // Read the input map\n    string map;\n    cin >> map;\n    // Calculate the dimensions of the map\n    int rows, cols;\n    tie(rows, cols) = calculateDimensions(map);\n    // Merge adjacent cells with the same fruit\n    mergeSameFruitCells(map);\n    // Count the number of rows and columns after merging\n    int mergedRows, mergedCols;\n    tie(mergedRows, mergedCols) = countDimensions(map);\n    // Output the number of people who can receive a share\n    cout << mergedRows * mergedCols << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n// Function to calculate the diameter of a roll cake\nint diameter(int radius) {\n    return 2 * radius;\n}\n\n// Function to calculate the volume of a roll cake\nint volume(int radius) {\n    return 3.14 * radius * radius;\n}\n\n// Function to check if a set of roll cakes can fit inside a box\nbool canFit(int boxLength, int cakeRadii[], int numCakes) {\n    int totalVolume = 0;\n    for (int i = 0; i < numCakes; i++) {\n        totalVolume += volume(cakeRadii[i]);\n    }\n    return totalVolume <= boxLength;\n}\n\nint main() {\n    int boxLength;\n    cin >> boxLength;\n\n    // Get the radii of the roll cakes\n    int cakeRadii[12];\n    for (int i = 0; i < 12; i++) {\n        cin >> cakeRadii[i];\n    }\n\n    // Check if the roll cakes can fit inside the box\n    bool canFit = canFit(boxLength, cakeRadii, 12);\n\n    // Output \"OK\" if the roll cakes can fit, or \"NA\" if they can't\n    if (canFit) {\n        cout << \"OK\" << endl;\n    } else {\n        cout << \"NA\" << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate the badge level based on the input times\nstring getBadgeLevel(double t1, double t2) {\n    // AAA level\n    if (t1 <= 35 && t2 <= 110) return \"AAA\";\n    // AA level\n    if (t1 <= 37 && t2 <= 117) return \"AA\";\n    // A level\n    if (t1 <= 40 && t2 <= 123) return \"A\";\n    // B level\n    if (t1 <= 43 && t2 <= 129) return \"B\";\n    // C level\n    if (t1 <= 50 && t2 <= 145) return \"C\";\n    // D level\n    if (t1 <= 55 && t2 <= 156) return \"D\";\n    // E level\n    if (t1 <= 60 && t2 <= 180) return \"E\";\n    // NA\n    return \"NA\";\n}\n\nint main() {\n    double t1, t2;\n    cin >> t1 >> t2;\n    string badgeLevel = getBadgeLevel(t1, t2);\n    cout << badgeLevel << endl;\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int y1, m1, d1, y2, m2, d2;\n    cin >> y1 >> m1 >> d1 >> y2 >> m2 >> d2;\n\n    // Check if the first date is after the second date\n    if (y1 > y2 || (y1 == y2 && m1 > m2) || (y1 == y2 && m1 == m2 && d1 > d2)) {\n        cout << \"Error: First date is after second date\" << endl;\n        return 1;\n    }\n\n    // Calculate the difference between the two dates\n    int diff = (y2 - y1) * 365 + (m2 - m1) * 30 + (d2 - d1);\n\n    // Check if the first date is a leap year\n    if (y1 % 4 == 0 && y1 % 100 != 0) {\n        // Add an extra day for the leap year\n        diff++;\n    }\n\n    // Check if the second date is a leap year\n    if (y2 % 4 == 0 && y2 % 100 != 0) {\n        // Subtract an extra day for the leap year\n        diff--;\n    }\n\n    // Output the result\n    cout << \"Day(s): \" << diff << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\n// Function to convert a poke bell message to a regular string message\nstring pokeBellToStr(string message) {\n  // Define a map to convert numbers to letters\n  map<int, char> letterMap = {\n    {11, 'a'}, {15, 'o'}, {16, 'i'}, {17, 'u'}, {18, 'e'}, {19, 's'}, {20, 't'}, {21, 'r'}, {22, 'n'}, {23, 'd'}, {24, 'l'}, {25, 'c'}, {26, 'h'}, {27, 'b'}, {28, 'p'}, {29, 'q'}, {30, 'f'}, {31, 'g'}, {32, 'j'}, {33, 'k'}, {34, 'x'}, {35, 'y'}, {36, 'z'}\n  };\n\n  // Iterate through the message and convert each number to its corresponding letter\n  for (int i = 0; i < message.size(); i++) {\n    int num = message[i] - '0';\n    if (num < 10) {\n      // If the number is less than 10, it represents a letter\n      message[i] = letterMap[num];\n    } else if (num == 10) {\n      // If the number is 10, it represents a space\n      message[i] = ' ';\n    } else {\n      // If the number is greater than 10, it's an invalid character\n      message[i] = '?';\n    }\n  }\n\n  return message;\n}\n\n// Main function to read and convert messages\nint main() {\n  string message;\n  while (cin >> message) {\n    // Convert the poke bell message to a regular string message\n    string convertedMessage = pokeBellToStr(message);\n\n    // Output the converted message or \"NA\" if it contains invalid characters\n    if (convertedMessage.empty()) {\n      cout << \"NA\" << endl;\n    } else {\n      cout << convertedMessage << endl;\n    }\n  }\n\n  return 0;\n}",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to print a line of asterisks\nvoid printLine(int numAsterisks) {\n    for (int i = 0; i < numAsterisks; i++) {\n        cout << \"*\";\n    }\n    cout << endl;\n}\n\n// Function to print a row of asterisks\nvoid printRow(int numAsterisks, int numSpaces) {\n    for (int i = 0; i < numAsterisks; i++) {\n        cout << \"*\";\n    }\n    for (int i = 0; i < numSpaces; i++) {\n        cout << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    int numTests;\n    cin >> numTests;\n\n    // Loop through each test case\n    for (int i = 0; i < numTests; i++) {\n        int numDigits;\n        cin >> numDigits;\n\n        // Print the row of asterisks for the top row\n        printRow(5, numDigits);\n\n        // Print the row of asterisks for the bottom row\n        printRow(5, numDigits);\n\n        // Print the middle row of asterisks\n        printLine(numDigits);\n\n        // Print a line of spaces\n        printLine(numDigits);\n\n        // Print the middle row of asterisks again\n        printLine(numDigits);\n\n        // Print the bottom row of asterisks\n        printRow(5, numDigits);\n\n        // Print a line of spaces\n        printLine(numDigits);\n\n        // Print the top row of asterisks again\n        printRow(5, numDigits);\n\n        cout << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_WALL = 100;\nconst int MAX_POSITION = 100;\n\nstruct Wall {\n    int wx, wy, r;\n};\n\nstruct Position {\n    int tx, ty, sx, sy;\n};\n\nbool isVisible(Wall wall, Position position) {\n    // Calculate the distance between the wall and the position\n    int dx = wall.wx - position.tx;\n    int dy = wall.wy - position.ty;\n    int distance = sqrt(dx * dx + dy * dy);\n\n    // Check if the distance is less than or equal to the sum of the radii\n    return distance <= wall.r + position.sx;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // Initialize the walls and positions\n    Wall walls[MAX_WALL];\n    Position positions[MAX_POSITION];\n\n    // Read the walls and positions\n    for (int i = 0; i < n; i++) {\n        cin >> walls[i].wx >> walls[i].wy >> walls[i].r;\n    }\n\n    for (int i = 0; i < m; i++) {\n        cin >> positions[i].tx >> positions[i].ty >> positions[i].sx >> positions[i].sy;\n    }\n\n    // Check if the positions are visible to each other\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (i != j && isVisible(walls[i], positions[j])) {\n                cout << \"Danger\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    // If all positions are safe, print \"Safe\"\n    cout << \"Safe\" << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\n\n// A structure to represent a car in the train\nstruct Car {\n    char id; // The car's identifier\n    int position; // The car's position in the train\n    vector<int> connections; // The cars connected to this car\n};\n\n// A function to parse the movement records and build the train formation\nvoid buildTrain(vector<string> records) {\n    vector<Car> train;\n    map<char, int> carPositions;\n\n    // Iterate through the movement records\n    for (const string& record : records) {\n        // Extract the car identifiers and their positions in the train\n        char prevId = record[0];\n        char currId = record[1];\n        int prevPosition = carPositions[prevId];\n        int currPosition = carPositions[currId];\n\n        // Update the car positions and connections\n        carPositions[prevId] = prevPosition + 1;\n        carPositions[currId] = currPosition + 1;\n        train.push_back(Car{prevId, prevPosition, {currId}});\n        train.push_back(Car{currId, currPosition, {prevId}});\n    }\n\n    // Output the train formation\n    for (const Car& car : train) {\n        cout << car.id << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    // Read the number of movement records\n    int n;\n    cin >> n;\n\n    // Read the movement records\n    vector<string> records(n);\n    for (int i = 0; i < n; i++) {\n        cin >> records[i];\n    }\n\n    // Build the train formation\n    buildTrain(records);\n\n    return 0;\n}"
]